name: CI

on:
  push:
    branches:
      - master
    tags:
      - 'v*'
    paths: ['.github/workflows/build.yml',
            '**/CMakeLists.txt',
            '**/Makefile',
            '**/*.mk',
            '**/*.cmake',
            '**/*.in',
            '**/*.h',
            '**/*.hpp',
            '**/*.c',
            '**/*.cpp',
            '**/*.cu',
            '**/*.cuh',
            '**/*.cl',
            '**/*.swift',
            '**/*.m',
            '**/*.mm',
            '**/*.metal',
            '**/*.comp',
            '**/*.java']

  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      create_release:
        description: 'Create new release'
        required: true
        type: boolean
      pre_release_tag:
        description: 'Pre-release tag name'
        required: false
        type: string
      run_type:
        description: 'Workflow type to run'
        required: true
        type: choice
        options:
          - full-ci
          - release-only

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref && github.ref || github.run_id }}
  cancel-in-progress: true

permissions:
  contents: write  # for creating release

env:
  BRANCH_NAME: ${{ github.head_ref || github.ref_name }}
  VCPKG_BINARY_SOURCES: "clear;x-gha,readwrite"

jobs:
  determine-tag:
    runs-on: ubuntu-latest
    outputs:
      tag_name: ${{ steps.tag.outputs.name }}
      should_release: ${{ steps.tag.outputs.should_release }}

    steps:
      - name: Checkout with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine tag name
        id: tag
        shell: bash
        run: |
          BUILD_NUMBER=$(git rev-list --count HEAD)
          SHORT_HASH=$(git rev-parse --short=7 HEAD)
          CUSTOM_TAG="${{ github.event.inputs.pre_release_tag }}"
          SHOULD_RELEASE="false"

          echo "Raw values:"
          echo "BUILD_NUMBER: $BUILD_NUMBER"
          echo "SHORT_HASH: $SHORT_HASH"
          echo "BRANCH_NAME: ${{ env.BRANCH_NAME }}"
          echo "CUSTOM_TAG: $CUSTOM_TAG"

          if [[ "${{ github.ref_type }}" == "tag" ]]; then
            echo "Using pushed tag name"
            TAG_NAME="${{ github.ref_name }}"
            SHOULD_RELEASE="true"
          elif [[ -n "$CUSTOM_TAG" ]]; then
            echo "Using custom tag"
            TAG_NAME="${CUSTOM_TAG}"
            SHOULD_RELEASE="true"
          elif [[ "${{ github.event.inputs.create_release }}" == "true" ]]; then
            echo "Manual release requested"
            SHOULD_RELEASE="true"
            TAG_NAME="b${BUILD_NUMBER}"
          elif [[ "${{ env.BRANCH_NAME }}" == "master" ]]; then
            echo "Using master branch format"
            TAG_NAME="b${BUILD_NUMBER}"
            SHOULD_RELEASE="false"
          else
            echo "Using non-master branch format"
            SAFE_NAME=$(echo "${{ env.BRANCH_NAME }}" | tr '/' '-')
            TAG_NAME="${SAFE_NAME}-b${BUILD_NUMBER}-${SHORT_HASH}"
            SHOULD_RELEASE="false"
          fi

          echo "Final tag name: $TAG_NAME"
          echo "Should release: $SHOULD_RELEASE"
          echo "name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT

  ubuntu-build-vulkan-x64:
    needs: determine-tag
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || github.event.inputs.run_type == 'full-ci' || github.event.inputs.run_type == 'release-only' }}
    name: Ubuntu x64 (Vulkan)
    runs-on: ubuntu-22.04
    env:
      ARCH: x64
      DEB_ARCH: amd64
      TRIPLET: x86_64-linux-gnu
      COMPILER_PACKAGES: ""
      BLAS_PACKAGE: ""
      PACKAGE_SUFFIX: "-vulkan"
      EXTRA_CMAKE: "-DWHISPER_SDL2=ON"
      VULKAN_SDK_VERSION: "1.4.328.1"

    steps:
      - name: Clone
        uses: actions/checkout@v4

      - name: Cache Vulkan SDK
        id: cache-vulkan
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/vulkan-sdk
          key: ${{ runner.os }}-vulkan-${{ env.VULKAN_SDK_VERSION }}-${{ github.run_id }}
          restore-keys: |
            ${{ runner.os }}-vulkan-${{ env.VULKAN_SDK_VERSION }}-

      - name: Check Vulkan cache status
        run: |
          if [ "${{ steps.cache-vulkan.outputs.cache-hit }}" == "true" ]; then
            echo "Vulkan SDK cache hit - using cached installation"
            echo "Installation time saved: ~2-3 minutes"
          else
            echo "Vulkan SDK cache miss - will install and cache for future runs"
            echo "This will take approximately 2-3 minutes"
          fi

      - name: Install Vulkan SDK
        if: steps.cache-vulkan.outputs.cache-hit != 'true'
        run: |
          # Download Vulkan SDK
          mkdir -p ${{ github.workspace }}/vulkan-sdk
          cd ${{ github.workspace }}/vulkan-sdk
          
          # Set SDK filename
          SDK_FILENAME="vulkansdk-linux-x86_64-${{ env.VULKAN_SDK_VERSION }}.tar.xz"
          
          # Download the specific version of Vulkan SDK
          echo "Downloading Vulkan SDK ${{ env.VULKAN_SDK_VERSION }}..."
          if ! wget -q --show-progress "https://sdk.lunarg.com/sdk/download/${{ env.VULKAN_SDK_VERSION }}/linux/${SDK_FILENAME}"; then
            echo "Error: Failed to download Vulkan SDK"
            exit 1
          fi
          
          # Extract SDK
          echo "Extracting Vulkan SDK..."
          if ! tar -xf "${SDK_FILENAME}"; then
            echo "Error: Failed to extract Vulkan SDK"
            exit 1
          fi
          rm "${SDK_FILENAME}"
          
          # Verify extraction
          if [ ! -d "${{ env.VULKAN_SDK_VERSION }}/x86_64" ]; then
            echo "Error: Vulkan SDK directory structure not found after extraction"
            exit 1
          fi
          echo "Vulkan SDK installation completed successfully"

      - name: Set Vulkan environment
        run: |
          echo "VULKAN_SDK=${{ github.workspace }}/vulkan-sdk/${{ env.VULKAN_SDK_VERSION }}/x86_64" >> $GITHUB_ENV
          echo "${{ github.workspace }}/vulkan-sdk/${{ env.VULKAN_SDK_VERSION }}/x86_64/bin" >> $GITHUB_PATH
          echo "LD_LIBRARY_PATH=${{ github.workspace }}/vulkan-sdk/${{ env.VULKAN_SDK_VERSION }}/x86_64/lib${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}" >> $GITHUB_ENV
          echo "VK_LAYER_PATH=${{ github.workspace }}/vulkan-sdk/${{ env.VULKAN_SDK_VERSION }}/x86_64/etc/vulkan/explicit_layer.d" >> $GITHUB_ENV

      - name: Install dependencies
        run: |
          sudo dpkg --add-architecture ${DEB_ARCH}
          sudo apt-get update
          EXTRA_PACKAGES=""
          if [[ -n "${BLAS_PACKAGE}" ]]; then
            EXTRA_PACKAGES="${BLAS_PACKAGE}:${DEB_ARCH}"
          fi
          # Install XCB libraries for X11/Vulkan integration with manually installed SDK
          sudo apt-get install -y build-essential cmake ninja-build pkg-config \
            ${COMPILER_PACKAGES} \
            libsdl2-dev:${DEB_ARCH} \
            libvulkan1:${DEB_ARCH} \
            libxcb1-dev libxcb-keysyms1-dev libx11-xcb-dev \
            $EXTRA_PACKAGES

      - name: Configure
        run: |
          git config --global --add safe.directory /workspace
          export PKG_CONFIG_LIBDIR="/usr/lib/${TRIPLET}/pkgconfig:/usr/share/pkgconfig"
          cmake -S . -B build -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DGGML_VULKAN=ON \
            -DGGML_AVX512=ON \
            -DBUILD_SHARED_LIBS=OFF \
            -DGGML_STATIC=ON \
            -DWHISPER_BUILD_EXAMPLES=ON \
            -DWHISPER_BUILD_TESTS=OFF \
            -DWHISPER_BUILD_SERVER=OFF \
            ${EXTRA_CMAKE}

      - name: Build
        run: cmake --build build --config Release -j $(nproc)

      - name: Package whisper-cli and whisper-bench (Ubuntu)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        run: |
          mkdir -p dist
          cp build/bin/whisper-cli build/bin/whisper-bench dist/
          pushd dist
          zip -9 "whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}.zip" whisper-cli whisper-bench
          popd

      - name: Upload whisper-cli package
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: whisper-cli-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}
          path: dist/whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}.zip

      - name: Cleanup workspace
        if: always()
        run: |
          rm -rf build dist
          sudo rm -rf /var/cache/apt/archives || true

  ubuntu-build-cuda-x64:
    needs: determine-tag
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || github.event.inputs.run_type == 'full-ci' || github.event.inputs.run_type == 'release-only' }}
    name: Ubuntu x64 (CUDA)
    runs-on: ubuntu-22.04
    env:
      ARCH: x64
      DEB_ARCH: amd64
      TRIPLET: x86_64-linux-gnu
      COMPILER_PACKAGES: ""
      BLAS_PACKAGE: ""
      PACKAGE_SUFFIX: "-cuda"
      EXTRA_CMAKE: "-DWHISPER_SDL2=ON -DGGML_CUDA=ON -DGGML_VULKAN=OFF"
      CUDA_VERSION: "12.4"

    steps:
      - name: Clone
        uses: actions/checkout@v4

      - name: Cache CUDA Toolkit
        id: cache-cuda
        uses: actions/cache@v4
        with:
          path: /usr/local/cuda-${{ env.CUDA_VERSION }}
          key: ${{ runner.os }}-cuda-${{ env.CUDA_VERSION }}-${{ github.run_id }}
          restore-keys: |
            ${{ runner.os }}-cuda-${{ env.CUDA_VERSION }}-

      - name: Check CUDA cache status
        run: |
          if [ "${{ steps.cache-cuda.outputs.cache-hit }}" == "true" ]; then
            echo "CUDA cache hit - using cached installation"
            echo "Installation time saved: ~5-10 minutes"
          else
            echo "CUDA cache miss - will install and cache for future runs"
            echo "This will take approximately 5-10 minutes"
          fi

      - name: Install CUDA Toolkit
        if: steps.cache-cuda.outputs.cache-hit != 'true'
        run: |
          # Install CUDA repository
          wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/cuda-keyring_1.0-1_all.deb
          sudo dpkg -i cuda-keyring_1.0-1_all.deb
          sudo apt-get update
          
          # Install minimal CUDA toolkit to minimize disk usage
          # Using cuda-minimal-build metapackage which includes only build essentials
          sudo apt-get install -y cuda-minimal-build-12-4 cuda-libraries-dev-12-4

      - name: Set CUDA environment variables
        run: |
          echo "CUDA_PATH=/usr/local/cuda-${{ env.CUDA_VERSION }}" >> $GITHUB_ENV
          echo "/usr/local/cuda-${{ env.CUDA_VERSION }}/bin" >> $GITHUB_PATH
          echo "LD_LIBRARY_PATH=/usr/local/cuda-${{ env.CUDA_VERSION }}/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}" >> $GITHUB_ENV

      - name: Install dependencies
        run: |
          sudo dpkg --add-architecture ${DEB_ARCH}
          sudo apt-get update
          EXTRA_PACKAGES=""
          if [[ -n "${BLAS_PACKAGE}" ]]; then
            EXTRA_PACKAGES="${BLAS_PACKAGE}:${DEB_ARCH}"
          fi
          sudo apt-get install -y build-essential cmake ninja-build pkg-config \
            ${COMPILER_PACKAGES} \
            libsdl2-dev:${DEB_ARCH} \
            $EXTRA_PACKAGES
          sudo apt-get clean
          sudo rm -rf /var/lib/apt/lists/*

      - name: Configure
        run: |
          git config --global --add safe.directory /workspace
          export PKG_CONFIG_LIBDIR="/usr/lib/${TRIPLET}/pkgconfig:/usr/share/pkgconfig"
          cmake -S . -B build -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DGGML_VULKAN=OFF \
            -DGGML_AVX512=ON \
            -DBUILD_SHARED_LIBS=ON \
            -DGGML_STATIC=OFF \
            -DWHISPER_BUILD_EXAMPLES=ON \
            -DWHISPER_BUILD_TESTS=OFF \
            -DWHISPER_BUILD_SERVER=OFF \
            ${EXTRA_CMAKE}

      - name: Build
        run: cmake --build build --config Release -j $(nproc)

      - name: Package whisper-cli and whisper-bench (Ubuntu CUDA)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        run: |
          mkdir -p dist
          
          # Copy executables
          cp build/bin/whisper-cli build/bin/whisper-bench dist/
          
          # Copy project shared libraries if they exist
          if ls build/lib/*.so* 1>/dev/null 2>&1; then
            echo "Copying project shared libraries from build/lib/"
            cp -P build/lib/*.so* dist/
          fi
          if ls build/bin/*.so* 1>/dev/null 2>&1; then
            echo "Copying project shared libraries from build/bin/"
            cp -P build/bin/*.so* dist/
          fi
          
          # Copy essential CUDA runtime shared libraries
          CUDA_LIB_DIR="/usr/local/cuda-${{ env.CUDA_VERSION }}/lib64"
          if [ -d "$CUDA_LIB_DIR" ]; then
            echo "Copying essential CUDA runtime libraries from: $CUDA_LIB_DIR"
            # Only copy the essential libraries needed for CUDA functionality
            # These are the Linux equivalents of the Windows CUDA DLLs
            REQUIRED_LIBS=(
              "libcublas.so.12"
              "libcublasLt.so.12"
              "libcudart.so.12"
              "libnvrtc.so.12"
              "libnvblas.so.12"
            )
            
            COPIED_COUNT=0
            MISSING_LIBS=""
            for lib in "${REQUIRED_LIBS[@]}"; do
              # Check if library files exist and copy them with their symlinks
              if ls "$CUDA_LIB_DIR"/${lib}* 1>/dev/null 2>&1; then
                cp -P "$CUDA_LIB_DIR"/${lib}* dist/
                echo "Copied $lib"
                COPIED_COUNT=$((COPIED_COUNT + 1))
              else
                echo "Warning: $lib not found in $CUDA_LIB_DIR"
                MISSING_LIBS="$MISSING_LIBS $lib"
              fi
            done
            
            # Also copy nvrtc-builtins if available
            if ls "$CUDA_LIB_DIR"/libnvrtc-builtins.so* 1>/dev/null 2>&1; then
              cp -P "$CUDA_LIB_DIR"/libnvrtc-builtins.so* dist/
              echo "Copied libnvrtc-builtins"
              COPIED_COUNT=$((COPIED_COUNT + 1))
            fi
            
            if [ $COPIED_COUNT -eq 0 ]; then
              echo "Error: No required CUDA libraries found"
              exit 1
            fi
            
            echo "Successfully copied $COPIED_COUNT CUDA libraries"
            if [ -n "$MISSING_LIBS" ]; then
              echo "Warning: Some libraries were not found:$MISSING_LIBS"
            fi
          else
            echo "Error: CUDA library directory not found at $CUDA_LIB_DIR"
            exit 1
          fi
          
          # List all files in dist for verification
          echo "Package contents:"
          ls -la dist/
          
          pushd dist
          zip -9 "whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}.zip" *
          popd

      - name: Upload whisper-cli package
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: whisper-cli-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}
          path: dist/whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}.zip

      - name: Cleanup workspace
        if: always()
        run: |
          rm -rf build dist
          sudo rm -rf /var/cache/apt/archives || true

  macos-build:
    needs: determine-tag
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || github.event.inputs.run_type == 'full-ci' || github.event.inputs.run_type == 'release-only' }}
    name: macOS ${{ matrix.name }}
    runs-on: macos-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: Metal + CoreML
            coreml: ON
            suffix: coreml
          - name: Metal only
            coreml: OFF
            suffix: metal

    steps:
      - name: Clone
        uses: actions/checkout@v4

      - name: Dependencies
        run: |
          brew update
          cmake --version
          brew install sdl2

      - name: Build
        run: |
          sysctl -a
          git config --global --add safe.directory /workspace
          cmake -B build -G Xcode \
            -DGGML_METAL_USE_BF16=ON \
            -DGGML_METAL_EMBED_LIBRARY=ON \
            -DGGML_COREML=${{ matrix.coreml }} \
            -DGGML_AVX512=ON \
            -DBUILD_SHARED_LIBS=OFF \
            -DGGML_STATIC=ON \
            -DWHISPER_BUILD_EXAMPLES=ON \
            -DWHISPER_BUILD_TESTS=OFF \
            -DWHISPER_BUILD_SERVER=OFF \
            -DCMAKE_OSX_ARCHITECTURES="arm64;x86_64"
          cmake --build build --config Release -j $(sysctl -n hw.logicalcpu)

      - name: Package whisper-cli and whisper-bench
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        run: |
          mkdir -p dist
          cp build/bin/Release/whisper-cli build/bin/Release/whisper-bench dist/
          pushd dist
          zip -9 "whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-macos-universal-${{ matrix.suffix }}.zip" whisper-cli whisper-bench
          popd

      - name: Upload whisper-cli package
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: whisper-cli-macos-${{ matrix.suffix }}
          path: dist/whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-macos-universal-${{ matrix.suffix }}.zip



  windows-build-vulkan:
    needs: determine-tag
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || github.event.inputs.run_type == 'full-ci' || github.event.inputs.run_type == 'release-only' }}
    name: Windows x64 (Vulkan)
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64

    runs-on: windows-latest
    
    env:
      VULKAN_SDK_VERSION: "1.4.328.1"

    steps:
      - name: Clone
        uses: actions/checkout@v4

      - name: Install Ninja
        run: choco install ninja -y

      - name: Cache Vulkan SDK
        id: cache-vulkan
        uses: actions/cache@v4
        with:
          path: C:\VulkanSDK
          key: ${{ runner.os }}-vulkan-${{ env.VULKAN_SDK_VERSION }}-${{ github.run_id }}
          restore-keys: |
            ${{ runner.os }}-vulkan-${{ env.VULKAN_SDK_VERSION }}-

      - name: Install Vulkan SDK
        if: steps.cache-vulkan.outputs.cache-hit != 'true'
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          Write-Host "Vulkan SDK cache miss - installing"
          Write-Host "Installing Vulkan SDK via winget"

          $installArgs = @(
            'install',
            '--id', 'KhronosGroup.VulkanSDK',
            '--accept-package-agreements',
            '--accept-source-agreements',
            '--silent',
            '--source', 'winget'
          )

          winget @installArgs

          if ($LASTEXITCODE -ne 0) {
            Write-Error "winget failed to install Vulkan SDK (exit $LASTEXITCODE)"
            exit $LASTEXITCODE
          }

      - name: Locate Vulkan SDK
        shell: powershell
        run: |
          $searchRoots = @(
            "C:\\VulkanSDK",
            "$Env:ProgramFiles\\VulkanSDK",
            "$Env:ProgramFiles(x86)\\VulkanSDK"
          )

          $sdkRoot = $null
          foreach ($root in $searchRoots) {
            if (-not (Test-Path $root)) {
              continue
            }

            $candidate = Get-ChildItem $root -Directory | Sort-Object Name -Descending | Select-Object -First 1
            if ($candidate) {
              $sdkRoot = $candidate.FullName
              break
            }
          }

          if (-not $sdkRoot) {
            Write-Error "Vulkan SDK not found"
            exit 1
          }
          
          $cacheHit = '${{ steps.cache-vulkan.outputs.cache-hit }}'
          if ($cacheHit -eq 'true') {
            Write-Host "Vulkan SDK cache hit - using cached installation at: $sdkRoot"
          } else {
            Write-Host "Vulkan SDK installed at: $sdkRoot"
          }

          "VULKAN_SDK=$sdkRoot" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append

      - name: Configure (Vulkan)
        shell: cmd
        run: |
          for /f "usebackq tokens=*" %%i in (`"%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe" -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath`) do set VS_PATH=%%i
          if not defined VS_PATH exit /b 1
          call "%VS_PATH%\Common7\Tools\VsDevCmd.bat" -host_arch=x64 -arch=x64
          if not defined VULKAN_SDK exit /b 1
          set "PATH=%VULKAN_SDK%\Bin;%PATH%"
          cmake -S . -B build -G "Ninja" ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DGGML_AVX512=ON ^
            -DBUILD_SHARED_LIBS=OFF ^
            -DGGML_STATIC=ON ^
            -DGGML_VULKAN=ON ^
            -DWHISPER_SDL2=OFF ^
            -DWHISPER_BUILD_TESTS=OFF ^
            -DWHISPER_BUILD_EXAMPLES=ON ^
            -DWHISPER_BUILD_SERVER=OFF

      - name: Build (Vulkan)
        shell: cmd
        run: |
          for /f "usebackq tokens=*" %%i in (`"%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe" -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath`) do set VS_PATH=%%i
          if not defined VS_PATH exit /b 1
          call "%VS_PATH%\Common7\Tools\VsDevCmd.bat" -host_arch=x64 -arch=x64
          if not defined VULKAN_SDK exit /b 1
          set "PATH=%VULKAN_SDK%\Bin;%PATH%"
          cmake --build build --config Release -- -v

      - name: Package whisper-cli and whisper-bench (Windows ${{ matrix.arch }} Vulkan)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        shell: powershell
        run: |
          # Create dist directory
          New-Item -ItemType Directory -Force -Path dist | Out-Null
          
          # Copy executables
          Copy-Item build\bin\whisper-cli.exe dist\
          Copy-Item build\bin\whisper-bench.exe dist\
          
          # Copy any build DLLs if they exist
          if (Test-Path "build\bin\*.dll") {
            Copy-Item build\bin\*.dll dist\
          }
          
          # Create zip package
          Push-Location dist
          $filesToZip = @(Get-ChildItem -Path "*.exe" -Name)
          if (Test-Path "*.dll") {
            $filesToZip += @(Get-ChildItem -Path "*.dll" -Name)
          }
          tar.exe -a -c -f ..\whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-vulkan.zip $filesToZip
          Pop-Location
          Move-Item whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-vulkan.zip dist\

      - name: Upload whisper-cli package (Windows ${{ matrix.arch }} Vulkan)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: whisper-cli-windows-${{ matrix.arch }}-vulkan
          path: dist/whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-vulkan.zip

  windows-build-cuda:
    needs: determine-tag
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || github.event.inputs.run_type == 'full-ci' || github.event.inputs.run_type == 'release-only' }}
    name: Windows x64 (CUDA)
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64

    runs-on: windows-latest
    
    env:
      # CUDA Toolkit installation directory on Windows
      CUDA_PATH: C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.4
      # CUDA version for cache key - update when upgrading CUDA
      CUDA_VERSION: "12.4.1"

    steps:
      - name: Clone
        uses: actions/checkout@v4

      - name: Install Ninja
        run: choco install ninja -y

      - name: Cache CUDA Toolkit
        id: cache-cuda
        uses: actions/cache@v4
        with:
          path: C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA
          # Cache key includes run_id to prevent cache collision during concurrent saves
          key: ${{ runner.os }}-cuda-${{ env.CUDA_VERSION }}-${{ github.run_id }}
          restore-keys: |
            ${{ runner.os }}-cuda-${{ env.CUDA_VERSION }}-

      - name: Check CUDA cache status
        shell: powershell
        run: |
          $cacheHit = '${{ steps.cache-cuda.outputs.cache-hit }}'
          if ($cacheHit -eq 'true') {
            Write-Host "CUDA cache hit - using cached installation"
            Write-Host "Installation time saved: ~10 minutes"
          } else {
            Write-Host "CUDA cache miss - will install and cache for future runs"
            Write-Host "This will take approximately 10 minutes"
          }

      - name: Install CUDA Toolkit
        if: steps.cache-cuda.outputs.cache-hit != 'true'
        shell: powershell
        run: |
          Write-Host "Installing NVIDIA CUDA Toolkit..."
          Write-Host "Note: This installation will be cached for subsequent workflow runs."
          
          # Install CUDA Toolkit via Chocolatey (better CUDA support than winget)
          # Note: Chocolatey cuda package doesn't support patch versions (e.g., 12.4.1)
          # Install latest CUDA 12.x available
          choco install cuda -y --no-progress
          
          if ($LASTEXITCODE -ne 0) {
            Write-Host "Error: Installation failed with exit code $LASTEXITCODE"
            Write-Host ""
            Write-Host "Installation failed and cannot continue."
            exit 1
          } else {
            Write-Host "Installation completed successfully"
          }

      - name: Set CUDA environment variables and verify installation
        shell: powershell
        run: |
          # Detect actual CUDA installation path
          # Chocolatey installs latest version which may differ from our env var
          $cudaBasePath = "C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA"
          
          if (Test-Path $cudaBasePath) {
            # Find the installed CUDA version directory
            $installedVersions = Get-ChildItem -Path $cudaBasePath -Directory | Where-Object { $_.Name -match '^v\d+\.\d+$' } | Sort-Object Name -Descending
            
            if ($installedVersions.Count -gt 0) {
              $actualCudaPath = $installedVersions[0].FullName
              Write-Host "Detected CUDA installation at: $actualCudaPath"
              
              # Set CUDA environment variables with actual path
              echo "CUDA_PATH=$actualCudaPath" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append
              
              # Add CUDA to PATH
              $cudaBinPath = Join-Path $actualCudaPath "bin"
              echo "$cudaBinPath" | Out-File -FilePath $Env:GITHUB_PATH -Encoding utf8 -Append
              
              # Verify essential components are present
              $nvccPath = Join-Path $actualCudaPath "bin\nvcc.exe"
              $includeDir = Join-Path $actualCudaPath "include"
              $libDir = Join-Path $actualCudaPath "lib\x64"
              
              $installValid = $true
              
              if (-not (Test-Path $nvccPath)) {
                Write-Host "Error: nvcc.exe not found - CUDA installation may be incomplete"
                $installValid = $false
              } elseif (-not (Test-Path $includeDir)) {
                Write-Host "Error: Include directory not found - CUDA installation may be incomplete"
                $installValid = $false
              } elseif (-not (Test-Path $libDir)) {
                Write-Host "Error: Library directory not found - CUDA installation may be incomplete"
                $installValid = $false
              } else {
                Write-Host "CUDA Toolkit verified at: $actualCudaPath"
                Write-Host "Essential components found (nvcc.exe, include, lib)"
              }
              
              if (-not $installValid) {
                Write-Host ""
                Write-Host "Installation validation failed. The build will likely fail."
                exit 1
              }
            } else {
              Write-Host "Error: No CUDA version directories found in $cudaBasePath"
              exit 1
            }
          } else {
            Write-Host "Error: CUDA base directory not found at $cudaBasePath"
            exit 1
          }

      - name: Configure (CUDA)
        shell: cmd
        run: |
          for /f "usebackq tokens=*" %%i in (`"%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe" -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath`) do set VS_PATH=%%i
          if not defined VS_PATH exit /b 1
          call "%VS_PATH%\Common7\Tools\VsDevCmd.bat" -host_arch=x64 -arch=x64
          cmake -S . -B build -G Ninja ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DGGML_AVX512=ON ^
            -DBUILD_SHARED_LIBS=OFF ^
            -DGGML_STATIC=ON ^
            -DGGML_CUDA=ON ^
            -DWHISPER_SDL2=OFF ^
            -DWHISPER_BUILD_TESTS=OFF ^
            -DWHISPER_BUILD_EXAMPLES=ON ^
            -DWHISPER_BUILD_SERVER=OFF

      - name: Build (CUDA)
        shell: cmd
        run: |
          for /f "usebackq tokens=*" %%i in (`"%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe" -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath`) do set VS_PATH=%%i
          if not defined VS_PATH exit /b 1
          call "%VS_PATH%\Common7\Tools\VsDevCmd.bat" -host_arch=x64 -arch=x64
          cmake --build build --config Release -- -v

      - name: Package whisper-cli and whisper-bench (Windows ${{ matrix.arch }} CUDA)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        shell: powershell
        run: |
          # Create dist directory
          New-Item -ItemType Directory -Force -Path dist | Out-Null
          
          # Copy executables
          Copy-Item build\bin\whisper-cli.exe dist\
          Copy-Item build\bin\whisper-bench.exe dist\
          
          # Copy any build DLLs if they exist
          if (Test-Path "build\bin\*.dll") {
            Copy-Item build\bin\*.dll dist\
          }
          
          # Copy specific CUDA DLLs from CUDA_PATH\bin to minimize package size
          if ($env:CUDA_PATH -and (Test-Path "$env:CUDA_PATH\bin")) {
            Write-Host "Copying essential CUDA runtime DLLs from: $env:CUDA_PATH\bin"
            # Only copy the essential DLLs needed for CUDA functionality
            $requiredDlls = @(
              'cublas64_12.dll',
              'cublasLt64_12.dll',
              'cudart64_12.dll',
              'nvrtc-builtins64_129.dll',
              'nvblas64_12.dll',
              'nvrtc64_120_0.dll'
            )
            
            $copiedCount = 0
            foreach ($dll in $requiredDlls) {
              $dllPath = Join-Path "$env:CUDA_PATH\bin" $dll
              if (Test-Path $dllPath) {
                Copy-Item $dllPath dist\
                Write-Host "Copied $dll"
                $copiedCount++
              } else {
                Write-Host "Warning: $dll not found at $dllPath"
              }
            }
            
            if ($copiedCount -eq 0) {
              Write-Host "Error: No required CUDA DLLs found"
              exit 1
            } else {
              Write-Host "Successfully copied $copiedCount CUDA DLLs"
            }
          } else {
            Write-Host "Error: CUDA_PATH not set or bin directory not found"
            exit 1
          }
          
          # Create zip package
          Push-Location dist
          $filesToZip = @(Get-ChildItem -Path "*.exe" -Name)
          if (Test-Path "*.dll") {
            $filesToZip += @(Get-ChildItem -Path "*.dll" -Name)
          }
          tar.exe -a -c -f ..\whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-cuda.zip $filesToZip
          Pop-Location
          Move-Item whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-cuda.zip dist\

      - name: Upload whisper-cli package (Windows ${{ matrix.arch }} CUDA)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: whisper-cli-windows-${{ matrix.arch }}-cuda
          path: dist/whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-cuda.zip

  create-release:
    if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
    needs: [determine-tag, ubuntu-build-vulkan-x64, ubuntu-build-cuda-x64, macos-build, windows-build-vulkan, windows-build-cuda]
    runs-on: ubuntu-latest

    steps:
      - name: Download whisper-cli packages
        uses: actions/download-artifact@v4
        with:
          pattern: whisper-cli-*
          path: release
          merge-multiple: true

      # Full packages are available as workflow artifacts but excluded from releases to reduce size
      # Uncomment below to include full packages (with all examples) in releases
      # - name: Download full packages
      #   uses: actions/download-artifact@v4
      #   with:
      #     pattern: whisper.cpp-full-*
      #     path: release
      #     merge-multiple: true

      - name: Display package sizes
        run: |
          echo "ðŸ“¦ Package Sizes:"
          echo "===================="
          cd release
          
          # Check if any zip files exist
          if ! ls *.zip >/dev/null 2>&1; then
            echo "No package files found"
            exit 0
          fi
          
          # Display each package with human-readable size
          # Use awk to safely handle large file sizes and avoid integer overflow
          for file in *.zip; do
            if [ -f "$file" ]; then
              size_bytes=$(stat -c %s "$file" 2>/dev/null)
              if [ -n "$size_bytes" ]; then
                size_info=$(awk -v size="$size_bytes" 'BEGIN {
                  mb = size / 1048576
                  if (mb >= 1024) {
                    gb = mb / 1024
                    printf "%.2f GB", gb
                  } else {
                    printf "%.2f MB", mb
                  }
                }')
                echo "  â€¢ $file: $size_info"
              else
                echo "  â€¢ $file: Unable to determine size"
              fi
            fi
          done
          
          # Calculate and display total size
          total_size=$(find . -name "*.zip" -type f -exec stat -c %s {} + 2>/dev/null | awk '{sum += $1} END {print sum}')
          if [ -n "$total_size" ] && [ "$total_size" -gt 0 ]; then
            total_info=$(awk -v size="$total_size" 'BEGIN {
              mb = size / 1048576
              if (mb >= 1024) {
                gb = mb / 1024
                printf "%.2f GB", gb
              } else {
                printf "%.2f MB", mb
              }
            }')
            echo "===================="
            echo "Total: $total_info"
          fi

      - name: Create GitHub release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.determine-tag.outputs.tag_name }}
          files: |
            release/*
          generate_release_notes: true
          prerelease: ${{ github.ref_type != 'tag' }}
