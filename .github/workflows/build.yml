name: CI

on:
  push:
    branches:
      - master
    tags:
      - 'v*'
    paths: ['.github/workflows/build.yml',
            '**/CMakeLists.txt',
            '**/Makefile',
            '**/*.mk',
            '**/*.cmake',
            '**/*.in',
            '**/*.h',
            '**/*.hpp',
            '**/*.c',
            '**/*.cpp',
            '**/*.cu',
            '**/*.cuh',
            '**/*.cl',
            '**/*.swift',
            '**/*.m',
            '**/*.mm',
            '**/*.metal',
            '**/*.comp',
            '**/*.java']

  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      create_release:
        description: 'Create new release'
        required: true
        type: boolean
      pre_release_tag:
        description: 'Pre-release tag name'
        required: false
        type: string
      run_type:
        description: 'Workflow type to run'
        required: true
        type: choice
        options:
          - full-ci
          - release-only

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref && github.ref || github.run_id }}
  cancel-in-progress: true

permissions:
  contents: write  # for creating release

env:
  BRANCH_NAME: ${{ github.head_ref || github.ref_name }}
  VCPKG_BINARY_SOURCES: "clear;x-gha,readwrite"

jobs:
  determine-tag:
    runs-on: ubuntu-latest
    outputs:
      tag_name: ${{ steps.tag.outputs.name }}
      should_release: ${{ steps.tag.outputs.should_release }}

    steps:
      - name: Checkout with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine tag name
        id: tag
        shell: bash
        run: |
          BUILD_NUMBER=$(git rev-list --count HEAD)
          SHORT_HASH=$(git rev-parse --short=7 HEAD)
          CUSTOM_TAG="${{ github.event.inputs.pre_release_tag }}"
          SHOULD_RELEASE="false"

          echo "Raw values:"
          echo "BUILD_NUMBER: $BUILD_NUMBER"
          echo "SHORT_HASH: $SHORT_HASH"
          echo "BRANCH_NAME: ${{ env.BRANCH_NAME }}"
          echo "CUSTOM_TAG: $CUSTOM_TAG"

          if [[ "${{ github.ref_type }}" == "tag" ]]; then
            echo "Using pushed tag name"
            TAG_NAME="${{ github.ref_name }}"
            SHOULD_RELEASE="true"
          elif [[ -n "$CUSTOM_TAG" ]]; then
            echo "Using custom tag"
            TAG_NAME="${CUSTOM_TAG}"
            SHOULD_RELEASE="true"
          elif [[ "${{ github.event.inputs.create_release }}" == "true" ]]; then
            echo "Manual release requested"
            SHOULD_RELEASE="true"
            TAG_NAME="b${BUILD_NUMBER}"
          elif [[ "${{ env.BRANCH_NAME }}" == "master" ]]; then
            echo "Using master branch format"
            TAG_NAME="b${BUILD_NUMBER}"
            SHOULD_RELEASE="false"
          else
            echo "Using non-master branch format"
            SAFE_NAME=$(echo "${{ env.BRANCH_NAME }}" | tr '/' '-')
            TAG_NAME="${SAFE_NAME}-b${BUILD_NUMBER}-${SHORT_HASH}"
            SHOULD_RELEASE="false"
          fi

          echo "Final tag name: $TAG_NAME"
          echo "Should release: $SHOULD_RELEASE"
          echo "name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT

  ubuntu-build-vulkan-x64:
    needs: determine-tag
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || github.event.inputs.run_type == 'full-ci' || github.event.inputs.run_type == 'release-only' }}
    name: Ubuntu x64 (Vulkan)
    runs-on: ubuntu-22.04
    env:
      ARCH: x64
      DEB_ARCH: amd64
      TRIPLET: x86_64-linux-gnu
      COMPILER_PACKAGES: ""
      BLAS_PACKAGE: ""
      PACKAGE_SUFFIX: "-vulkan"
      EXTRA_CMAKE: "-DWHISPER_SDL2=ON"
      VULKAN_SDK_VERSION: "1.4.328.1"

    steps:
      - name: Clone
        uses: actions/checkout@v4

      - name: Cache Vulkan SDK
        id: cache-vulkan
        uses: actions/cache@v4
        with:
          path: ~/vulkan-sdk
          key: ${{ runner.os }}-vulkan-${{ env.VULKAN_SDK_VERSION }}

      - name: Check Vulkan cache status
        run: |
          if [ "${{ steps.cache-vulkan.outputs.cache-hit }}" == "true" ]; then
            echo "Vulkan SDK cache hit - using cached installation"
            echo "Installation time saved: ~2-5 minutes"
          else
            echo "Vulkan SDK cache miss - will install and cache for future runs"
            echo "This will take approximately 2-5 minutes"
          fi

      - name: Install Vulkan SDK
        if: steps.cache-vulkan.outputs.cache-hit != 'true'
        run: |
          set -e
          echo "Installing Vulkan SDK..."
          wget -qO- https://packages.lunarg.com/lunarg-signing-key-pub.asc | sudo tee /etc/apt/trusted.gpg.d/lunarg.asc
          sudo wget -qO /etc/apt/sources.list.d/lunarg-vulkan-jammy.list https://packages.lunarg.com/vulkan/lunarg-vulkan-jammy.list
          sudo apt-get update
          sudo apt-get install -y vulkan-sdk
          
          # Verify installation before caching
          if [ ! -d /usr/share/vulkan ] || [ ! -d /usr/include/vulkan ]; then
            echo "✗ Error: Vulkan SDK installation incomplete"
            exit 1
          fi
          
          # Cache the SDK for future runs
          echo "Caching Vulkan SDK files..."
          mkdir -p ~/vulkan-sdk/share ~/vulkan-sdk/include ~/vulkan-sdk/lib
          
          # Copy with verification
          if ! sudo cp -r /usr/share/vulkan ~/vulkan-sdk/share/ 2>/dev/null; then
            echo "⚠ Warning: Failed to cache /usr/share/vulkan"
          fi
          
          if ! sudo cp -r /usr/include/vulkan ~/vulkan-sdk/include/ 2>/dev/null; then
            echo "⚠ Warning: Failed to cache /usr/include/vulkan"
          fi
          
          if ! sudo cp -r /usr/lib/x86_64-linux-gnu/libvulkan* ~/vulkan-sdk/lib/ 2>/dev/null; then
            echo "⚠ Warning: Failed to cache vulkan libraries"
          fi
          
          # Create cache integrity marker
          echo "${{ env.VULKAN_SDK_VERSION }}" > ~/vulkan-sdk/version.txt
          echo "✓ Vulkan SDK installed and cached"

      - name: Set Vulkan SDK environment variables
        run: |
          set -e
          CACHE_VALID=false
          
          if [ "${{ steps.cache-vulkan.outputs.cache-hit }}" == "true" ]; then
            echo "Validating cached Vulkan SDK..."
            
            # Check cache integrity
            if [ -f ~/vulkan-sdk/version.txt ]; then
              CACHED_VERSION=$(cat ~/vulkan-sdk/version.txt)
              if [ "$CACHED_VERSION" == "${{ env.VULKAN_SDK_VERSION }}" ]; then
                echo "✓ Cache version matches: $CACHED_VERSION"
                
                # Verify critical files exist in cache
                if [ -d ~/vulkan-sdk/share/vulkan ] && [ -d ~/vulkan-sdk/include/vulkan ]; then
                  echo "✓ Cache validation passed"
                  CACHE_VALID=true
                else
                  echo "⚠ Warning: Cache incomplete - missing critical directories"
                fi
              else
                echo "⚠ Warning: Cache version mismatch (cached: $CACHED_VERSION, expected: ${{ env.VULKAN_SDK_VERSION }})"
              fi
            else
              echo "⚠ Warning: Cache integrity marker missing"
            fi
            
            if [ "$CACHE_VALID" == "true" ]; then
              echo "Restoring Vulkan SDK from cache..."
              sudo mkdir -p /usr/share /usr/include /usr/lib/x86_64-linux-gnu
              
              # Restore with error checking
              if [ -d ~/vulkan-sdk/share/vulkan ]; then
                sudo cp -r ~/vulkan-sdk/share/vulkan /usr/share/ || echo "⚠ Warning: Failed to restore /usr/share/vulkan"
              fi
              
              if [ -d ~/vulkan-sdk/include/vulkan ]; then
                sudo cp -r ~/vulkan-sdk/include/vulkan /usr/include/ || echo "⚠ Warning: Failed to restore /usr/include/vulkan"
              fi
              
              if [ -d ~/vulkan-sdk/lib ]; then
                sudo cp ~/vulkan-sdk/lib/libvulkan* /usr/lib/x86_64-linux-gnu/ 2>/dev/null || echo "⚠ Warning: Failed to restore vulkan libraries"
              fi
              
              echo "✓ Cache restored successfully"
            else
              echo "⚠ Cache validation failed - will rely on libvulkan-dev package"
            fi
          fi
          
          # Verify final installation state
          if [ ! -d /usr/include/vulkan ]; then
            echo "✗ Error: Vulkan headers not found after restoration"
            exit 1
          fi
          
          echo "VULKAN_SDK=/usr" >> $GITHUB_ENV
          echo "✓ Vulkan SDK configured"

      - name: Install dependencies
        run: |
          sudo dpkg --add-architecture ${DEB_ARCH}
          sudo apt-get update
          EXTRA_PACKAGES=""
          if [[ -n "${BLAS_PACKAGE}" ]]; then
            EXTRA_PACKAGES="${BLAS_PACKAGE}:${DEB_ARCH}"
          fi
          sudo apt-get install -y build-essential cmake ninja-build pkg-config \
            ${COMPILER_PACKAGES} \
            libsdl2-dev:${DEB_ARCH} \
            libvulkan-dev:${DEB_ARCH} \
            $EXTRA_PACKAGES

      - name: Configure
        run: |
          git config --global --add safe.directory /workspace
          export PKG_CONFIG_LIBDIR="/usr/lib/${TRIPLET}/pkgconfig:/usr/share/pkgconfig"
          cmake -S . -B build -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DGGML_VULKAN=ON \
            -DBUILD_SHARED_LIBS=OFF \
            -DGGML_STATIC=ON \
            -DWHISPER_BUILD_EXAMPLES=ON \
            -DWHISPER_BUILD_TESTS=OFF \
            -DWHISPER_BUILD_SERVER=OFF \
            ${EXTRA_CMAKE}

      - name: Build
        run: cmake --build build --config Release -j $(nproc)

      - name: Package whisper-cli and whisper-bench (Ubuntu)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        run: |
          mkdir -p dist
          cp build/bin/whisper-cli build/bin/whisper-bench dist/
          pushd dist
          zip -9 "whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}.zip" whisper-cli whisper-bench
          popd

      - name: Upload whisper-cli package
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: whisper-cli-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}
          path: dist/whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}.zip

      - name: Cleanup workspace
        if: always()
        run: |
          rm -rf build dist
          sudo rm -rf /var/cache/apt/archives || true

  ubuntu-build-cuda-x64:
    needs: determine-tag
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || github.event.inputs.run_type == 'full-ci' || github.event.inputs.run_type == 'release-only' }}
    name: Ubuntu x64 (CUDA)
    runs-on: ubuntu-22.04
    env:
      ARCH: x64
      DEB_ARCH: amd64
      TRIPLET: x86_64-linux-gnu
      COMPILER_PACKAGES: ""
      BLAS_PACKAGE: ""
      PACKAGE_SUFFIX: "-cuda"
      EXTRA_CMAKE: "-DWHISPER_SDL2=ON -DGGML_CUDA=ON -DGGML_VULKAN=OFF"
      CUDA_VERSION: "12.4"

    steps:
      - name: Clone
        uses: actions/checkout@v4

      - name: Cache CUDA Toolkit
        id: cache-cuda
        uses: actions/cache@v4
        with:
          path: /usr/local/cuda-${{ env.CUDA_VERSION }}
          key: ${{ runner.os }}-cuda-${{ env.CUDA_VERSION }}

      - name: Check CUDA cache status
        run: |
          if [ "${{ steps.cache-cuda.outputs.cache-hit }}" == "true" ]; then
            echo "CUDA cache hit - using cached installation"
            echo "Installation time saved: ~5-10 minutes"
          else
            echo "CUDA cache miss - will install and cache for future runs"
            echo "This will take approximately 5-10 minutes"
          fi

      - name: Install CUDA Toolkit
        if: steps.cache-cuda.outputs.cache-hit != 'true'
        run: |
          set -e
          echo "Installing CUDA Toolkit..."
          # Install CUDA repository
          wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/cuda-keyring_1.0-1_all.deb
          sudo dpkg -i cuda-keyring_1.0-1_all.deb
          sudo apt-get update
          
          # Install minimal CUDA toolkit to minimize disk usage
          # Using cuda-minimal-build metapackage which includes only build essentials
          sudo apt-get install -y cuda-minimal-build-12-4 cuda-libraries-dev-12-4
          
          # Create cache integrity marker
          if [ -d "/usr/local/cuda-${{ env.CUDA_VERSION }}" ]; then
            echo "${{ env.CUDA_VERSION }}" > /usr/local/cuda-${{ env.CUDA_VERSION }}/version.txt
            echo "✓ CUDA Toolkit installed successfully"
          else
            echo "✗ Error: CUDA installation directory not found"
            exit 1
          fi

      - name: Set CUDA environment variables
        run: |
          echo "CUDA_PATH=/usr/local/cuda-${{ env.CUDA_VERSION }}" >> $GITHUB_ENV
          echo "/usr/local/cuda-${{ env.CUDA_VERSION }}/bin" >> $GITHUB_PATH
          echo "LD_LIBRARY_PATH=/usr/local/cuda-${{ env.CUDA_VERSION }}/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}" >> $GITHUB_ENV

      - name: Verify CUDA installation
        run: |
          set -e
          CUDA_PATH="/usr/local/cuda-${{ env.CUDA_VERSION }}"
          
          echo "Verifying CUDA installation at: $CUDA_PATH"
          
          # Check directory exists
          if [ ! -d "$CUDA_PATH" ]; then
            echo "✗ Error: CUDA installation directory not found at: $CUDA_PATH"
            exit 1
          fi
          
          # Validate cache integrity if from cache
          if [ "${{ steps.cache-cuda.outputs.cache-hit }}" == "true" ]; then
            echo "Validating cached CUDA installation..."
            
            if [ -f "$CUDA_PATH/version.txt" ]; then
              CACHED_VERSION=$(cat "$CUDA_PATH/version.txt")
              if [ "$CACHED_VERSION" != "${{ env.CUDA_VERSION }}" ]; then
                echo "⚠ Warning: Cache version mismatch (cached: $CACHED_VERSION, expected: ${{ env.CUDA_VERSION }})"
              else
                echo "✓ Cache version matches: $CACHED_VERSION"
              fi
            else
              echo "⚠ Warning: Cache integrity marker missing"
            fi
          fi
          
          # Check critical files exist
          MISSING_FILES=false
          
          if [ ! -f "$CUDA_PATH/bin/nvcc" ]; then
            echo "✗ Error: nvcc compiler not found at $CUDA_PATH/bin/nvcc"
            MISSING_FILES=true
          else
            echo "✓ Found nvcc compiler"
          fi
          
          if [ ! -d "$CUDA_PATH/include" ]; then
            echo "✗ Error: CUDA headers not found at $CUDA_PATH/include"
            MISSING_FILES=true
          else
            echo "✓ Found CUDA headers"
          fi
          
          if [ ! -d "$CUDA_PATH/lib64" ]; then
            echo "✗ Error: CUDA libraries not found at $CUDA_PATH/lib64"
            MISSING_FILES=true
          else
            echo "✓ Found CUDA libraries"
          fi
          
          if [ "$MISSING_FILES" == "true" ]; then
            echo ""
            echo "✗ CUDA installation is incomplete or corrupted"
            if [ "${{ steps.cache-cuda.outputs.cache-hit }}" == "true" ]; then
              echo "Suggestion: Clear the cache and re-run the workflow"
            fi
            exit 1
          fi
          
          echo ""
          echo "✓ CUDA installation verified successfully"
          
          if [ "${{ steps.cache-cuda.outputs.cache-hit }}" == "true" ]; then
            echo "✓ Using cached CUDA installation"
          else
            echo "✓ Using freshly installed CUDA"
          fi

      - name: Install dependencies
        run: |
          sudo dpkg --add-architecture ${DEB_ARCH}
          sudo apt-get update
          EXTRA_PACKAGES=""
          if [[ -n "${BLAS_PACKAGE}" ]]; then
            EXTRA_PACKAGES="${BLAS_PACKAGE}:${DEB_ARCH}"
          fi
          sudo apt-get install -y build-essential cmake ninja-build pkg-config \
            ${COMPILER_PACKAGES} \
            libsdl2-dev:${DEB_ARCH} \
            $EXTRA_PACKAGES
          sudo apt-get clean
          sudo rm -rf /var/lib/apt/lists/*

      - name: Configure
        run: |
          git config --global --add safe.directory /workspace
          export PKG_CONFIG_LIBDIR="/usr/lib/${TRIPLET}/pkgconfig:/usr/share/pkgconfig"
          cmake -S . -B build -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DGGML_VULKAN=OFF \
            -DBUILD_SHARED_LIBS=OFF \
            -DGGML_STATIC=ON \
            -DWHISPER_BUILD_EXAMPLES=ON \
            -DWHISPER_BUILD_TESTS=OFF \
            -DWHISPER_BUILD_SERVER=OFF \
            ${EXTRA_CMAKE}

      - name: Build
        run: cmake --build build --config Release -j $(nproc)

      - name: Cleanup before packaging
        run: |
          # Remove build artifacts except bin directory
          find build -mindepth 1 -maxdepth 1 ! -name bin -exec rm -rf {} +
          # Clean package manager caches
          sudo apt-get clean
          sudo rm -rf /var/cache/apt/archives /var/lib/apt/lists/* /tmp/* /var/tmp/* || true
          # Remove docker images if present
          docker system prune -af || true
          # Report disk usage
          df -h

      - name: Package whisper-cli and whisper-bench (Ubuntu)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        run: |
          mkdir -p dist
          cp build/bin/whisper-cli build/bin/whisper-bench dist/
          pushd dist
          zip -9 "whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}.zip" whisper-cli whisper-bench
          popd

      - name: Upload whisper-cli package
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: whisper-cli-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}
          path: dist/whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}.zip

  ubuntu-build-oneapi-x64:
    needs: determine-tag
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || github.event.inputs.run_type == 'full-ci' || github.event.inputs.run_type == 'release-only' }}
    name: Ubuntu x64 (IntelGPU)
    runs-on: ubuntu-22.04
    env:
      ARCH: x64
      DEB_ARCH: amd64
      TRIPLET: x86_64-linux-gnu
      PACKAGE_SUFFIX: "-oneapi"
      ONEAPI_VERSION: "2025.3"
      ONEAPI_INSTALL_PATH: /opt/intel/oneapi

    steps:
      - name: Clone
        uses: actions/checkout@v4

      - name: Cache Intel oneAPI
        id: cache-oneapi
        uses: actions/cache@v4
        with:
          path: ${{ env.ONEAPI_INSTALL_PATH }}
          key: ${{ runner.os }}-oneapi-${{ env.ONEAPI_VERSION }}

      - name: Check oneAPI cache status
        run: |
          if [ "${{ steps.cache-oneapi.outputs.cache-hit }}" == "true" ]; then
            echo "oneAPI cache hit - using cached installation"
            echo "Installation time saved: ~20 minutes"
          else
            echo "oneAPI cache miss - will install and cache for future runs"
            echo "This will take approximately 15-20 minutes"
          fi

      - name: Install Intel oneAPI Base Toolkit
        if: steps.cache-oneapi.outputs.cache-hit != 'true'
        run: |
          set -e
          echo "Installing Intel oneAPI Base Toolkit..."
          echo "Note: This installation will be cached for subsequent workflow runs."
          
          # Add Intel repository
          wget -O- https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB | gpg --dearmor | sudo tee /usr/share/keyrings/oneapi-archive-keyring.gpg > /dev/null
          echo "deb [signed-by=/usr/share/keyrings/oneapi-archive-keyring.gpg] https://apt.repos.intel.com/oneapi all main" | sudo tee /etc/apt/sources.list.d/oneAPI.list
          
          # Install oneAPI Base Toolkit
          sudo apt-get update
          sudo apt-get install -y intel-oneapi-compiler-dpcpp-cpp intel-oneapi-mkl-devel
          
          # Create cache integrity marker
          if [ -d "${{ env.ONEAPI_INSTALL_PATH }}" ]; then
            echo "${{ env.ONEAPI_VERSION }}" > ${{ env.ONEAPI_INSTALL_PATH }}/version.txt
            echo "✓ Installation completed successfully"
          else
            echo "✗ Error: oneAPI installation directory not found"
            exit 1
          fi

      - name: Set oneAPI environment variables and verify installation
        run: |
          set -e
          ONEAPI_PATH="${{ env.ONEAPI_INSTALL_PATH }}"
          
          echo "Verifying oneAPI installation at: $ONEAPI_PATH"
          
          # Check directory exists
          if [ ! -d "$ONEAPI_PATH" ]; then
            echo "✗ Error: oneAPI installation directory not found at: $ONEAPI_PATH"
            exit 1
          fi
          
          # Validate cache integrity if from cache
          if [ "${{ steps.cache-oneapi.outputs.cache-hit }}" == "true" ]; then
            echo "Validating cached oneAPI installation..."
            
            if [ -f "$ONEAPI_PATH/version.txt" ]; then
              CACHED_VERSION=$(cat "$ONEAPI_PATH/version.txt")
              if [ "$CACHED_VERSION" != "${{ env.ONEAPI_VERSION }}" ]; then
                echo "⚠ Warning: Cache version mismatch (cached: $CACHED_VERSION, expected: ${{ env.ONEAPI_VERSION }})"
              else
                echo "✓ Cache version matches: $CACHED_VERSION"
              fi
            else
              echo "⚠ Warning: Cache integrity marker missing (may be from older cache)"
            fi
          fi
          
          # Check critical files exist
          if [ ! -f "$ONEAPI_PATH/setvars.sh" ]; then
            echo "✗ Error: setvars.sh not found - oneAPI installation may be incomplete"
            exit 1
          fi
          echo "✓ Found setvars.sh"
          
          if [ ! -d "$ONEAPI_PATH/compiler" ]; then
            echo "✗ Error: Compiler directory not found - oneAPI installation may be incomplete"
            exit 1
          fi
          echo "✓ Found compiler directory"
          
          # Source oneAPI environment
          source $ONEAPI_PATH/setvars.sh
          
          # Verify compiler is available and executable
          if ! which icpx > /dev/null 2>&1; then
            echo "✗ Error: icpx compiler not found in PATH after sourcing setvars.sh"
            exit 1
          fi
          echo "✓ icpx compiler found in PATH"
          
          # Test that compiler can run
          if ! icpx --version > /dev/null 2>&1; then
            echo "✗ Error: icpx compiler found but cannot execute"
            exit 1
          fi
          echo "✓ icpx compiler is executable"
          
          echo ""
          echo "✓ oneAPI installation verified successfully"
          
          if [ "${{ steps.cache-oneapi.outputs.cache-hit }}" == "true" ]; then
            echo "✓ Using cached oneAPI installation"
          else
            echo "✓ Using freshly installed oneAPI"
          fi

      - name: Install dependencies
        run: |
          sudo dpkg --add-architecture ${DEB_ARCH}
          sudo apt-get update
          sudo apt-get install -y build-essential cmake ninja-build pkg-config \
            libsdl2-dev:${DEB_ARCH}

      - name: Configure (Intel GPU)
        run: |
          source ${{ env.ONEAPI_INSTALL_PATH }}/setvars.sh
          cmake -S . -B build -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_C_COMPILER=icx \
            -DCMAKE_CXX_COMPILER=icpx \
            -DBUILD_SHARED_LIBS=OFF \
            -DGGML_STATIC=ON \
            -DGGML_SYCL=ON \
            -DGGML_SYCL_F16=ON \
            -DWHISPER_SYCL=ON \
            -DWHISPER_SYCL_F16=ON \
            -DWHISPER_SDL2=OFF \
            -DWHISPER_BUILD_TESTS=OFF \
            -DWHISPER_BUILD_EXAMPLES=ON \
            -DWHISPER_BUILD_SERVER=OFF

      - name: Build (Intel GPU)
        run: |
          source ${{ env.ONEAPI_INSTALL_PATH }}/setvars.sh
          cmake --build build --config Release -j $(nproc)

      - name: Package whisper-cli and whisper-bench (Ubuntu)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        run: |
          mkdir -p dist
          cp build/bin/whisper-cli build/bin/whisper-bench dist/
          
          # Copy Intel oneAPI runtime libraries required for execution
          # These libraries are needed to run SYCL-compiled binaries
          source ${{ env.ONEAPI_INSTALL_PATH }}/setvars.sh
          
          # Search for libraries in multiple locations
          ONEAPI_LIB_PATHS=(
            "${{ env.ONEAPI_INSTALL_PATH }}/compiler/latest/lib"
            "${{ env.ONEAPI_INSTALL_PATH }}/compiler/latest/linux/lib"
            "${{ env.ONEAPI_INSTALL_PATH }}/compiler/latest/linux/lib/x64"
          )
          
          # Copy SYCL runtime libraries (including libsycl.so.8 for 2025.x)
          for lib_path in "${ONEAPI_LIB_PATHS[@]}"; do
            if [ -d "$lib_path" ]; then
              cp "$lib_path"/libsycl.so* dist/ 2>/dev/null || true
              cp "$lib_path"/libpi_*.so dist/ 2>/dev/null || true
              cp "$lib_path"/libOpenCL.so* dist/ 2>/dev/null || true
              cp "$lib_path"/libsvml.so* dist/ 2>/dev/null || true
              cp "$lib_path"/libirng.so* dist/ 2>/dev/null || true
              cp "$lib_path"/libimf.so* dist/ 2>/dev/null || true
              cp "$lib_path"/libintlc.so* dist/ 2>/dev/null || true
            fi
          done
          
          # Verify critical libraries are present
          if ! ls dist/libsycl.so* 1> /dev/null 2>&1; then
            echo "⚠ Warning: libsycl.so not found in package"
            echo "Searched locations:"
            for lib_path in "${ONEAPI_LIB_PATHS[@]}"; do
              echo "  - $lib_path"
              if [ -d "$lib_path" ]; then
                echo "    Contents: $(ls "$lib_path"/libsycl* 2>/dev/null || echo 'none')"
              fi
            done
          else
            echo "✓ Found SYCL libraries:"
            ls -lh dist/libsycl.so*
          fi
          
          pushd dist
          zip -9 "whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}.zip" whisper-cli whisper-bench *.so*
          popd

      - name: Upload whisper-cli package
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: whisper-cli-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}
          path: dist/whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}.zip


  macos-build:
    needs: determine-tag
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || github.event.inputs.run_type == 'full-ci' || github.event.inputs.run_type == 'release-only' }}
    name: macOS ${{ matrix.name }}
    runs-on: macos-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: Metal + CoreML
            coreml: ON
            suffix: coreml
          - name: Metal only
            coreml: OFF
            suffix: metal

    steps:
      - name: Clone
        uses: actions/checkout@v4

      - name: Dependencies
        run: |
          brew update
          cmake --version
          brew install sdl2

      - name: Build
        run: |
          sysctl -a
          git config --global --add safe.directory /workspace
          cmake -B build -G Xcode \
            -DGGML_METAL_USE_BF16=ON \
            -DGGML_METAL_EMBED_LIBRARY=ON \
            -DGGML_COREML=${{ matrix.coreml }} \
            -DBUILD_SHARED_LIBS=OFF \
            -DGGML_STATIC=ON \
            -DWHISPER_BUILD_EXAMPLES=ON \
            -DWHISPER_BUILD_TESTS=OFF \
            -DWHISPER_BUILD_SERVER=OFF \
            -DCMAKE_OSX_ARCHITECTURES="arm64;x86_64"
          cmake --build build --config Release -j $(sysctl -n hw.logicalcpu)

      - name: Package whisper-cli and whisper-bench
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        run: |
          mkdir -p dist
          cp build/bin/Release/whisper-cli build/bin/Release/whisper-bench dist/
          pushd dist
          zip -9 "whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-macos-universal-${{ matrix.suffix }}.zip" whisper-cli whisper-bench
          popd

      - name: Upload whisper-cli package
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: whisper-cli-macos-${{ matrix.suffix }}
          path: dist/whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-macos-universal-${{ matrix.suffix }}.zip



  windows-build-vulkan-msvc:
    needs: determine-tag
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || github.event.inputs.run_type == 'full-ci' || github.event.inputs.run_type == 'release-only' }}
    name: Windows x64 (Vulkan)
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64

    runs-on: windows-latest
    
    env:
      VULKAN_SDK_VERSION: "1.4.328.1"

    steps:
      - name: Clone
        uses: actions/checkout@v4

      - name: Install Ninja
        run: choco install ninja -y

      - name: Cache Vulkan SDK
        id: cache-vulkan
        uses: actions/cache@v4
        with:
          path: C:\VulkanSDK
          key: ${{ runner.os }}-vulkan-msvc-${{ env.VULKAN_SDK_VERSION }}

      - name: Check Vulkan cache status
        shell: powershell
        run: |
          $cacheHit = '${{ steps.cache-vulkan.outputs.cache-hit }}'
          if ($cacheHit -eq 'true') {
            Write-Host "Vulkan SDK cache hit - using cached installation"
            Write-Host "Installation time saved: ~2-5 minutes"
          } else {
            Write-Host "Vulkan SDK cache miss - will install and cache for future runs"
            Write-Host "This will take approximately 2-5 minutes"
          }

      - name: Install Vulkan SDK
        if: steps.cache-vulkan.outputs.cache-hit != 'true'
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          Write-Host "Vulkan SDK cache miss - installing"
          Write-Host "Installing Vulkan SDK via winget"

          $installArgs = @(
            'install',
            '--id', 'KhronosGroup.VulkanSDK',
            '--accept-package-agreements',
            '--accept-source-agreements',
            '--silent',
            '--source', 'winget'
          )

          winget @installArgs

          if ($LASTEXITCODE -ne 0) {
            Write-Error "winget failed to install Vulkan SDK (exit $LASTEXITCODE)"
            exit $LASTEXITCODE
          }
          
          Write-Host "✓ Vulkan SDK installation completed"

      - name: Locate Vulkan SDK
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          
          $searchRoots = @(
            "C:\\VulkanSDK",
            "$Env:ProgramFiles\\VulkanSDK",
            "$Env:ProgramFiles(x86)\\VulkanSDK"
          )

          $sdkRoot = $null
          foreach ($root in $searchRoots) {
            if (-not (Test-Path $root)) {
              continue
            }

            $candidate = Get-ChildItem $root -Directory | Sort-Object Name -Descending | Select-Object -First 1
            if ($candidate) {
              $sdkRoot = $candidate.FullName
              break
            }
          }

          if (-not $sdkRoot) {
            Write-Error "Vulkan SDK not found in any expected location"
            exit 1
          }
          
          $cacheHit = '${{ steps.cache-vulkan.outputs.cache-hit }}'
          if ($cacheHit -eq 'true') {
            Write-Host "Vulkan SDK cache hit - using cached installation at: $sdkRoot"
          } else {
            Write-Host "Vulkan SDK installed at: $sdkRoot"
          }

          "VULKAN_SDK=$sdkRoot" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append
          
          # Create cache integrity marker
          "${{ env.VULKAN_SDK_VERSION }}" | Out-File -FilePath "$sdkRoot\version.txt" -Encoding utf8

      - name: Verify Vulkan SDK installation
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          
          if (-not $env:VULKAN_SDK) {
            Write-Error "VULKAN_SDK environment variable not set"
            exit 1
          }
          
          Write-Host "Verifying Vulkan SDK at: $env:VULKAN_SDK"
          
          # Validate cache integrity if from cache
          if ('${{ steps.cache-vulkan.outputs.cache-hit }}' -eq 'true') {
            Write-Host "Validating cached Vulkan SDK..."
            
            $versionFile = Join-Path $env:VULKAN_SDK "version.txt"
            if (Test-Path $versionFile) {
              $cachedVersion = Get-Content $versionFile -Raw
              $cachedVersion = $cachedVersion.Trim()
              if ($cachedVersion -ne "${{ env.VULKAN_SDK_VERSION }}") {
                Write-Host "⚠ Warning: Cache version mismatch (cached: $cachedVersion, expected: ${{ env.VULKAN_SDK_VERSION }})"
              } else {
                Write-Host "✓ Cache version matches: $cachedVersion"
              }
            } else {
              Write-Host "⚠ Warning: Cache integrity marker missing"
            }
          }
          
          # Check critical directories and files exist
          $missingComponents = @()
          
          $includeDir = Join-Path $env:VULKAN_SDK "Include"
          if (-not (Test-Path $includeDir)) {
            $missingComponents += "Include directory"
          } else {
            Write-Host "✓ Found Include directory"
          }
          
          $libDir = Join-Path $env:VULKAN_SDK "Lib"
          if (-not (Test-Path $libDir)) {
            $missingComponents += "Lib directory"
          } else {
            Write-Host "✓ Found Lib directory"
          }
          
          $binDir = Join-Path $env:VULKAN_SDK "Bin"
          if (-not (Test-Path $binDir)) {
            $missingComponents += "Bin directory"
          } else {
            Write-Host "✓ Found Bin directory"
          }
          
          if ($missingComponents.Count -gt 0) {
            Write-Host ""
            Write-Error "✗ Vulkan SDK installation is incomplete. Missing: $($missingComponents -join ', ')"
            if ('${{ steps.cache-vulkan.outputs.cache-hit }}' -eq 'true') {
              Write-Host "Suggestion: Clear the cache and re-run the workflow"
            }
            exit 1
          }
          
          Write-Host ""
          Write-Host "✓ Vulkan SDK installation verified successfully"

      - name: Configure (Vulkan MSVC)
        shell: cmd
        run: |
          for /f "usebackq tokens=*" %%i in (`"%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe" -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath`) do set VS_PATH=%%i
          if not defined VS_PATH exit /b 1
          call "%VS_PATH%\Common7\Tools\VsDevCmd.bat" -host_arch=x64 -arch=x64
          if not defined VULKAN_SDK exit /b 1
          set "PATH=%VULKAN_SDK%\Bin;%PATH%"
          cmake -S . -B build -G "Ninja" ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DBUILD_SHARED_LIBS=OFF ^
            -DGGML_STATIC=ON ^
            -DGGML_VULKAN=ON ^
            -DWHISPER_SDL2=OFF ^
            -DWHISPER_BUILD_TESTS=OFF ^
            -DWHISPER_BUILD_EXAMPLES=ON ^
            -DWHISPER_BUILD_SERVER=OFF

      - name: Build (Vulkan MSVC)
        shell: cmd
        run: |
          for /f "usebackq tokens=*" %%i in (`"%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe" -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath`) do set VS_PATH=%%i
          if not defined VS_PATH exit /b 1
          call "%VS_PATH%\Common7\Tools\VsDevCmd.bat" -host_arch=x64 -arch=x64
          if not defined VULKAN_SDK exit /b 1
          set "PATH=%VULKAN_SDK%\Bin;%PATH%"
          cmake --build build --config Release -- -v

      - name: Package whisper-cli and whisper-bench (Windows ${{ matrix.arch }} Vulkan MSVC)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        shell: cmd
        run: |
          mkdir dist
          copy build\bin\whisper-cli.exe dist\
          copy build\bin\whisper-bench.exe dist\
          if exist build\bin\*.dll copy build\bin\*.dll dist\
          pushd dist
          if exist *.dll (
            tar.exe -a -c -f ..\whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-vulkan-msvc.zip whisper-cli.exe whisper-bench.exe *.dll
          ) else (
            tar.exe -a -c -f ..\whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-vulkan-msvc.zip whisper-cli.exe whisper-bench.exe
          )
          popd
          move whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-vulkan-msvc.zip dist\

      - name: Upload whisper-cli package (Windows ${{ matrix.arch }} Vulkan MSVC)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: whisper-cli-windows-${{ matrix.arch }}-vulkan-msvc
          path: dist/whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-vulkan-msvc.zip

  windows-build-intelgpu:
    needs: determine-tag
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || github.event.inputs.run_type == 'full-ci' || github.event.inputs.run_type == 'release-only' }}
    name: Windows x64 (IntelGPU)
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64

    runs-on: windows-latest
    
    env:
      # Standard Intel oneAPI installation directory on Windows (oneAPI 2025.x)
      # Update this path if Intel changes their default installation location
      ONEAPI_INSTALL_PATH: C:\Program Files (x86)\Intel\oneAPI
      # oneAPI version for cache key - update when upgrading oneAPI
      ONEAPI_VERSION: "2025.3"

    steps:
      - name: Clone
        uses: actions/checkout@v4

      - name: Install Ninja
        run: choco install ninja -y

      - name: Cache Intel oneAPI
        id: cache-oneapi
        uses: actions/cache@v4
        with:
          path: ${{ env.ONEAPI_INSTALL_PATH }}
          # Cache key includes oneAPI version only - cache is shared across branches
          key: ${{ runner.os }}-oneapi-${{ env.ONEAPI_VERSION }}

      - name: Check oneAPI cache status
        shell: powershell
        run: |
          $cacheHit = '${{ steps.cache-oneapi.outputs.cache-hit }}'
          if ($cacheHit -eq 'true') {
            Write-Host "oneAPI cache hit - using cached installation"
            Write-Host "Installation time saved: ~20 minutes"
          } else {
            Write-Host "oneAPI cache miss - will install and cache for future runs"
            Write-Host "This will take approximately 15-20 minutes"
          }

      - name: Install Intel oneAPI Base Toolkit
        if: steps.cache-oneapi.outputs.cache-hit != 'true'
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          Write-Host "Installing Intel oneAPI Base Toolkit..."
          Write-Host "Note: This installation will be cached for subsequent workflow runs."
          
          # Install via winget - most reliable method
          # The installation is cached, so this only runs once
          winget install `
            --id Intel.oneAPI.BaseToolkit `
            --accept-package-agreements `
            --accept-source-agreements `
            --silent `
            --log "$env:TEMP\oneapi_install.log"
          
          if ($LASTEXITCODE -ne 0) {
            Write-Host "✗ Error: Installation failed with exit code $LASTEXITCODE"
            Write-Host "Check log at: $env:TEMP\oneapi_install.log"
            Write-Host ""
            Write-Host "Installation failed and cannot continue."
            exit 1
          }
          
          Write-Host "✓ Installation completed successfully"
          
          # Create cache integrity marker
          if (Test-Path "$env:ONEAPI_INSTALL_PATH") {
            "${{ env.ONEAPI_VERSION }}" | Out-File -FilePath "$env:ONEAPI_INSTALL_PATH\version.txt" -Encoding utf8
          }

      - name: Set oneAPI environment variables and verify installation
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          
          echo "ONEAPI_ROOT=$env:ONEAPI_INSTALL_PATH" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append
          
          Write-Host "Verifying oneAPI installation at: $env:ONEAPI_INSTALL_PATH"
          
          # Check directory exists
          if (-not (Test-Path $env:ONEAPI_INSTALL_PATH)) {
            Write-Error "✗ Error: oneAPI installation directory not found at: $env:ONEAPI_INSTALL_PATH"
            exit 1
          }
          
          # Validate cache integrity if from cache
          if ('${{ steps.cache-oneapi.outputs.cache-hit }}' -eq 'true') {
            Write-Host "Validating cached oneAPI installation..."
            
            $versionFile = Join-Path $env:ONEAPI_INSTALL_PATH "version.txt"
            if (Test-Path $versionFile) {
              $cachedVersion = Get-Content $versionFile -Raw
              $cachedVersion = $cachedVersion.Trim()
              if ($cachedVersion -ne "${{ env.ONEAPI_VERSION }}") {
                Write-Host "⚠ Warning: Cache version mismatch (cached: $cachedVersion, expected: ${{ env.ONEAPI_VERSION }})"
              } else {
                Write-Host "✓ Cache version matches: $cachedVersion"
              }
            } else {
              Write-Host "⚠ Warning: Cache integrity marker missing (may be from older cache)"
            }
          }
          
          # Verify essential components are present
          $setvarsPath = Join-Path $env:ONEAPI_INSTALL_PATH "setvars.bat"
          $compilerPath = Join-Path $env:ONEAPI_INSTALL_PATH "compiler"
          
          $missingComponents = @()
          
          if (-not (Test-Path $setvarsPath)) {
            $missingComponents += "setvars.bat"
          } else {
            Write-Host "✓ Found setvars.bat"
          }
          
          if (-not (Test-Path $compilerPath)) {
            $missingComponents += "compiler directory"
          } else {
            Write-Host "✓ Found compiler directory"
          }
          
          if ($missingComponents.Count -gt 0) {
            Write-Host ""
            Write-Error "✗ oneAPI installation is incomplete. Missing: $($missingComponents -join ', ')"
            if ('${{ steps.cache-oneapi.outputs.cache-hit }}' -eq 'true') {
              Write-Host "Suggestion: Clear the cache and re-run the workflow"
            }
            Write-Host "This can happen if:"
            Write-Host "  1. Installation was interrupted or incomplete"
            Write-Host "  2. Cache was corrupted"
            Write-Host "  3. Disk space ran out during installation"
            exit 1
          }
          
          Write-Host ""
          Write-Host "✓ oneAPI installation verified successfully"
          
          if ('${{ steps.cache-oneapi.outputs.cache-hit }}' -eq 'true') {
            Write-Host "✓ Using cached oneAPI installation"
          } else {
            Write-Host "✓ Using freshly installed oneAPI"
          }

      - name: Configure (Intel GPU)
        shell: cmd
        run: |
          call "%ONEAPI_ROOT%\setvars.bat"
          cmake -S . -B build -G Ninja ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DCMAKE_C_COMPILER=icx ^
            -DCMAKE_CXX_COMPILER=icx ^
            -DBUILD_SHARED_LIBS=OFF ^
            -DGGML_STATIC=ON ^
            -DGGML_SYCL=ON ^
            -DGGML_SYCL_F16=ON ^
            -DWHISPER_SYCL=ON ^
            -DWHISPER_SYCL_F16=ON ^
            -DWHISPER_SDL2=OFF ^
            -DWHISPER_BUILD_TESTS=OFF ^
            -DWHISPER_BUILD_EXAMPLES=ON ^
            -DWHISPER_BUILD_SERVER=OFF

      - name: Build (Intel GPU)
        shell: cmd
        run: |
          call "%ONEAPI_ROOT%\setvars.bat"
          cmake --build build --config Release -- -v

      - name: Copy oneAPI DLLs
        shell: powershell
        run: |
          # Copy Intel oneAPI runtime DLLs required for execution
          # These DLLs are needed to run SYCL-compiled binaries
          $oneapiRoot = "$env:ONEAPI_INSTALL_PATH"
          
          # Search for DLLs in multiple locations within oneAPI installation
          $dllPaths = @(
            "$oneapiRoot\compiler\latest\bin",
            "$oneapiRoot\compiler\latest\windows\bin",
            "$oneapiRoot\compiler\latest\windows\bin\intel64",
            "$oneapiRoot\mkl\latest\bin",
            "$oneapiRoot\mkl\latest\bin\intel64"
          )
          
          $requiredDlls = @(
            "sycl8.dll",
            "sycl7.dll",
            "pi_*.dll",
            "dnnl.dll",
            "mkl_sycl_blas*.dll",
            "svml_*.dll",
            "libmmd.dll",
            "libiomp5md.dll"
          )
          
          Write-Host "Copying oneAPI runtime DLLs to build/bin..."
          
          foreach ($dllPath in $dllPaths) {
            if (Test-Path $dllPath) {
              Write-Host "Searching in: $dllPath"
              foreach ($dllPattern in $requiredDlls) {
                Get-ChildItem -Path $dllPath -Filter $dllPattern -ErrorAction SilentlyContinue |
                ForEach-Object {
                  Write-Host "  Copying: $($_.Name)"
                  Copy-Item $_.FullName -Destination "build/bin" -Force
                }
              }
            }
          }
          
          # Verify critical DLLs are present
          Write-Host ""
          Write-Host "Verifying copied DLLs:"
          $criticalDlls = @("sycl*.dll", "dnnl.dll", "mkl_sycl_blas*.dll")
          $missingDlls = @()
          
          foreach ($dllPattern in $criticalDlls) {
            $found = Get-ChildItem -Path "build/bin" -Filter $dllPattern -ErrorAction SilentlyContinue
            if ($found) {
              Write-Host "[OK] Found: $($found.Name -join ', ')"
            } else {
              Write-Host "[WARNING] Not found: $dllPattern"
              $missingDlls += $dllPattern
            }
          }
          
          if ($missingDlls.Count -gt 0) {
            Write-Host ""
            Write-Host "Warning: Some DLLs were not found. Package may not run without oneAPI installed."
            Write-Host "Missing patterns: $($missingDlls -join ', ')"
          } else {
            Write-Host ""
            Write-Host "[OK] All critical oneAPI runtime DLLs copied successfully"
          }

      - name: Package whisper-cli and whisper-bench (Windows ${{ matrix.arch }} IntelGPU)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        shell: powershell
        run: |
          # Create dist directory
          New-Item -ItemType Directory -Force -Path dist | Out-Null
          
          # Copy executables
          Copy-Item build\bin\whisper-cli.exe dist\
          Copy-Item build\bin\whisper-bench.exe dist\
          
          # Copy build DLLs if they exist (static build may not have any)
          if (Test-Path "build\bin\*.dll") {
            Copy-Item build\bin\*.dll dist\
          }
          
          # Create zip package
          Push-Location dist
          $files = Get-ChildItem -File
          if ($files.Count -gt 2) {
            # Has DLLs
            tar.exe -a -c -f ..\whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-intelgpu.zip whisper-cli.exe whisper-bench.exe *.dll
          } else {
            # No DLLs (static build)
            tar.exe -a -c -f ..\whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-intelgpu.zip whisper-cli.exe whisper-bench.exe
          }
          Pop-Location
          Move-Item whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-intelgpu.zip dist\

      - name: Upload whisper-cli package (Windows ${{ matrix.arch }} IntelGPU)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: whisper-cli-windows-${{ matrix.arch }}-intelgpu
          path: dist/whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-intelgpu.zip

  windows-build-cuda:
    needs: determine-tag
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || github.event.inputs.run_type == 'full-ci' || github.event.inputs.run_type == 'release-only' }}
    name: Windows x64 (CUDA)
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64

    runs-on: windows-latest
    
    env:
      # CUDA Toolkit installation directory on Windows
      CUDA_PATH: C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.4
      # CUDA version for cache key - update when upgrading CUDA
      CUDA_VERSION: "12.4.1"

    steps:
      - name: Clone
        uses: actions/checkout@v4

      - name: Install Ninja
        run: choco install ninja -y

      - name: Cache CUDA Toolkit
        id: cache-cuda
        uses: actions/cache@v4
        with:
          path: C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA
          # Cache key includes CUDA version only - cache is shared across branches
          key: ${{ runner.os }}-cuda-${{ env.CUDA_VERSION }}

      - name: Check CUDA cache status
        shell: powershell
        run: |
          $cacheHit = '${{ steps.cache-cuda.outputs.cache-hit }}'
          if ($cacheHit -eq 'true') {
            Write-Host "CUDA cache hit - using cached installation"
            Write-Host "Installation time saved: ~10 minutes"
          } else {
            Write-Host "CUDA cache miss - will install and cache for future runs"
            Write-Host "This will take approximately 10 minutes"
          }

      - name: Install CUDA Toolkit
        if: steps.cache-cuda.outputs.cache-hit != 'true'
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          Write-Host "Installing NVIDIA CUDA Toolkit..."
          Write-Host "Note: This installation will be cached for subsequent workflow runs."
          
          # Install CUDA Toolkit via Chocolatey (better CUDA support than winget)
          # Note: Chocolatey cuda package doesn't support patch versions (e.g., 12.4.1)
          # Install latest CUDA 12.x available
          choco install cuda -y --no-progress
          
          if ($LASTEXITCODE -ne 0) {
            Write-Host "✗ Error: Installation failed with exit code $LASTEXITCODE"
            Write-Host ""
            Write-Host "Installation failed and cannot continue."
            exit 1
          }
          
          Write-Host "✓ Installation completed successfully"

      - name: Set CUDA environment variables and verify installation
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          
          # Detect actual CUDA installation path
          # Chocolatey installs latest version which may differ from our env var
          $cudaBasePath = "C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA"
          
          if (-not (Test-Path $cudaBasePath)) {
            Write-Error "✗ Error: CUDA base directory not found at $cudaBasePath"
            exit 1
          }
          
          # Find the installed CUDA version directory
          $installedVersions = Get-ChildItem -Path $cudaBasePath -Directory | Where-Object { $_.Name -match '^v\d+\.\d+$' } | Sort-Object Name -Descending
          
          if ($installedVersions.Count -eq 0) {
            Write-Error "✗ Error: No CUDA version directories found in $cudaBasePath"
            exit 1
          }
          
          $actualCudaPath = $installedVersions[0].FullName
          Write-Host "Detected CUDA installation at: $actualCudaPath"
          
          # Set CUDA environment variables with actual path
          echo "CUDA_PATH=$actualCudaPath" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append
          
          # Add CUDA to PATH
          $cudaBinPath = Join-Path $actualCudaPath "bin"
          echo "$cudaBinPath" | Out-File -FilePath $Env:GITHUB_PATH -Encoding utf8 -Append
          
          # Create/verify cache integrity marker
          if ('${{ steps.cache-cuda.outputs.cache-hit }}' -eq 'true') {
            Write-Host "Validating cached CUDA installation..."
            
            $versionFile = Join-Path $actualCudaPath "version.txt"
            if (Test-Path $versionFile) {
              $cachedVersion = Get-Content $versionFile -Raw
              $cachedVersion = $cachedVersion.Trim()
              Write-Host "✓ Cache version marker found: $cachedVersion"
            } else {
              Write-Host "⚠ Warning: Cache integrity marker missing (may be from older cache)"
            }
          } else {
            # Create integrity marker for new installations
            $versionFile = Join-Path $actualCudaPath "version.txt"
            "${{ env.CUDA_VERSION }}" | Out-File -FilePath $versionFile -Encoding utf8
          }
          
          # Verify essential components are present
          $missingComponents = @()
          
          $nvccPath = Join-Path $actualCudaPath "bin\nvcc.exe"
          if (-not (Test-Path $nvccPath)) {
            $missingComponents += "nvcc.exe"
          } else {
            Write-Host "✓ Found nvcc.exe"
          }
          
          $includeDir = Join-Path $actualCudaPath "include"
          if (-not (Test-Path $includeDir)) {
            $missingComponents += "include directory"
          } else {
            Write-Host "✓ Found include directory"
          }
          
          $libDir = Join-Path $actualCudaPath "lib\x64"
          if (-not (Test-Path $libDir)) {
            $missingComponents += "lib\x64 directory"
          } else {
            Write-Host "✓ Found lib\x64 directory"
          }
          
          if ($missingComponents.Count -gt 0) {
            Write-Host ""
            Write-Error "✗ CUDA installation is incomplete. Missing: $($missingComponents -join ', ')"
            if ('${{ steps.cache-cuda.outputs.cache-hit }}' -eq 'true') {
              Write-Host "Suggestion: Clear the cache and re-run the workflow"
            }
            exit 1
          }
          
          Write-Host ""
          Write-Host "✓ CUDA Toolkit verified successfully"
          
          if ('${{ steps.cache-cuda.outputs.cache-hit }}' -eq 'true') {
            Write-Host "✓ Using cached CUDA installation"
          } else {
            Write-Host "✓ Using freshly installed CUDA"
          }

      - name: Configure (CUDA)
        shell: cmd
        run: |
          for /f "usebackq tokens=*" %%i in (`"%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe" -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath`) do set VS_PATH=%%i
          if not defined VS_PATH exit /b 1
          call "%VS_PATH%\Common7\Tools\VsDevCmd.bat" -host_arch=x64 -arch=x64
          cmake -S . -B build -G Ninja ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DBUILD_SHARED_LIBS=OFF ^
            -DGGML_STATIC=ON ^
            -DGGML_CUDA=ON ^
            -DWHISPER_SDL2=OFF ^
            -DWHISPER_BUILD_TESTS=OFF ^
            -DWHISPER_BUILD_EXAMPLES=ON ^
            -DWHISPER_BUILD_SERVER=OFF

      - name: Build (CUDA)
        shell: cmd
        run: |
          for /f "usebackq tokens=*" %%i in (`"%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe" -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath`) do set VS_PATH=%%i
          if not defined VS_PATH exit /b 1
          call "%VS_PATH%\Common7\Tools\VsDevCmd.bat" -host_arch=x64 -arch=x64
          cmake --build build --config Release -- -v

      - name: Copy CUDA DLLs
        shell: powershell
        run: |
          Get-ChildItem "$env:CUDA_PATH\bin\" -Filter "*.dll" |
          Copy-Item -Destination "build/bin"

      - name: Package whisper-cli and whisper-bench (Windows ${{ matrix.arch }} CUDA)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        shell: cmd
        run: |
          mkdir dist
          copy build\bin\whisper-cli.exe dist\
          copy build\bin\whisper-bench.exe dist\
          if exist build\bin\*.dll copy build\bin\*.dll dist\
          pushd dist
          if exist *.dll (
            tar.exe -a -c -f ..\whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-cuda.zip whisper-cli.exe whisper-bench.exe *.dll
          ) else (
            tar.exe -a -c -f ..\whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-cuda.zip whisper-cli.exe whisper-bench.exe
          )
          popd
          move whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-cuda.zip dist\

      - name: Upload whisper-cli package (Windows ${{ matrix.arch }} CUDA)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: whisper-cli-windows-${{ matrix.arch }}-cuda
          path: dist/whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-cuda.zip

  create-release:
    if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
    needs: [determine-tag, ubuntu-build-vulkan-x64, ubuntu-build-cuda-x64, ubuntu-build-oneapi-x64, macos-build, windows-build-intelgpu, windows-build-vulkan-msvc, windows-build-cuda]
    runs-on: ubuntu-latest

    steps:
      - name: Download whisper-cli packages
        uses: actions/download-artifact@v4
        with:
          pattern: whisper-cli-*
          path: release
          merge-multiple: true

      # Full packages are available as workflow artifacts but excluded from releases to reduce size
      # Uncomment below to include full packages (with all examples) in releases
      # - name: Download full packages
      #   uses: actions/download-artifact@v4
      #   with:
      #     pattern: whisper.cpp-full-*
      #     path: release
      #     merge-multiple: true

      - name: Create GitHub release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.determine-tag.outputs.tag_name }}
          files: |
            release/*
          generate_release_notes: true
          prerelease: ${{ github.ref_type != 'tag' }}
