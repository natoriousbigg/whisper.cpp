name: CI

on:
  push:
    branches:
      - master
    tags:
      - 'v*'
    paths: ['.github/workflows/build.yml',
            '**/CMakeLists.txt',
            '**/Makefile',
            '**/*.mk',
            '**/*.cmake',
            '**/*.in',
            '**/*.h',
            '**/*.hpp',
            '**/*.c',
            '**/*.cpp',
            '**/*.cu',
            '**/*.cuh',
            '**/*.cl',
            '**/*.swift',
            '**/*.m',
            '**/*.mm',
            '**/*.metal',
            '**/*.comp',
            '**/*.java']

  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      create_release:
        description: 'Create new release'
        required: true
        type: boolean
      pre_release_tag:
        description: 'Pre-release tag name'
        required: false
        type: string
      run_type:
        description: 'Workflow type to run'
        required: true
        type: choice
        options:
          - full-ci
          - release-only

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref && github.ref || github.run_id }}
  cancel-in-progress: true

permissions:
  contents: write  # for creating release

env:
  BRANCH_NAME: ${{ github.head_ref || github.ref_name }}
  VCPKG_BINARY_SOURCES: "clear;x-gha,readwrite"

jobs:
  determine-tag:
    runs-on: ubuntu-latest
    outputs:
      tag_name: ${{ steps.tag.outputs.name }}
      should_release: ${{ steps.tag.outputs.should_release }}

    steps:
      - name: Checkout with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine tag name
        id: tag
        shell: bash
        run: |
          BUILD_NUMBER=$(git rev-list --count HEAD)
          SHORT_HASH=$(git rev-parse --short=7 HEAD)
          CUSTOM_TAG="${{ github.event.inputs.pre_release_tag }}"
          SHOULD_RELEASE="false"

          echo "Raw values:"
          echo "BUILD_NUMBER: $BUILD_NUMBER"
          echo "SHORT_HASH: $SHORT_HASH"
          echo "BRANCH_NAME: ${{ env.BRANCH_NAME }}"
          echo "CUSTOM_TAG: $CUSTOM_TAG"

          if [[ "${{ github.ref_type }}" == "tag" ]]; then
            echo "Using pushed tag name"
            TAG_NAME="${{ github.ref_name }}"
            SHOULD_RELEASE="true"
          elif [[ -n "$CUSTOM_TAG" ]]; then
            echo "Using custom tag"
            TAG_NAME="${CUSTOM_TAG}"
            SHOULD_RELEASE="true"
          elif [[ "${{ github.event.inputs.create_release }}" == "true" ]]; then
            echo "Manual release requested"
            SHOULD_RELEASE="true"
            TAG_NAME="b${BUILD_NUMBER}"
          elif [[ "${{ env.BRANCH_NAME }}" == "master" ]]; then
            echo "Using master branch format"
            TAG_NAME="b${BUILD_NUMBER}"
            SHOULD_RELEASE="false"
          else
            echo "Using non-master branch format"
            SAFE_NAME=$(echo "${{ env.BRANCH_NAME }}" | tr '/' '-')
            TAG_NAME="${SAFE_NAME}-b${BUILD_NUMBER}-${SHORT_HASH}"
            SHOULD_RELEASE="false"
          fi

          echo "Final tag name: $TAG_NAME"
          echo "Should release: $SHOULD_RELEASE"
          echo "name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT

  ubuntu-build-vulkan-x64:
    needs: determine-tag
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || github.event.inputs.run_type == 'full-ci' || github.event.inputs.run_type == 'release-only' }}
    name: Ubuntu x64 (Vulkan)
    runs-on: ubuntu-22.04
    env:
      ARCH: x64
      DEB_ARCH: amd64
      TRIPLET: x86_64-linux-gnu
      COMPILER_PACKAGES: ""
      BLAS_PACKAGE: ""
      PACKAGE_SUFFIX: "-vulkan"
      EXTRA_CMAKE: "-DWHISPER_SDL2=ON"
      VULKAN_SDK_VERSION: "1.3.283.0"

    steps:
      - name: Clone
        uses: actions/checkout@v4

      - name: Cache Vulkan SDK
        id: cache-vulkan
        uses: actions/cache@v4
        with:
          path: ~/vulkan-sdk
          key: ${{ runner.os }}-vulkan-${{ env.VULKAN_SDK_VERSION }}

      - name: Install dependencies
        run: |
          sudo dpkg --add-architecture ${DEB_ARCH}
          wget -qO- https://packages.lunarg.com/lunarg-signing-key-pub.asc | sudo tee /etc/apt/trusted.gpg.d/lunarg.asc
          sudo wget -qO /etc/apt/sources.list.d/lunarg-vulkan-jammy.list https://packages.lunarg.com/vulkan/lunarg-vulkan-jammy.list
          sudo apt-get update
          EXTRA_PACKAGES=""
          if [[ -n "${BLAS_PACKAGE}" ]]; then
            EXTRA_PACKAGES="${BLAS_PACKAGE}:${DEB_ARCH}"
          fi
          sudo apt-get install -y build-essential cmake ninja-build pkg-config \
            ${COMPILER_PACKAGES} \
            libsdl2-dev:${DEB_ARCH} \
            libvulkan-dev:${DEB_ARCH} \
            vulkan-sdk \
            $EXTRA_PACKAGES

      - name: Configure
        run: |
          git config --global --add safe.directory /workspace
          export PKG_CONFIG_LIBDIR="/usr/lib/${TRIPLET}/pkgconfig:/usr/share/pkgconfig"
          cmake -S . -B build -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DGGML_VULKAN=ON \
            -DBUILD_SHARED_LIBS=OFF \
            -DGGML_STATIC=ON \
            -DWHISPER_BUILD_EXAMPLES=ON \
            -DWHISPER_BUILD_TESTS=OFF \
            -DWHISPER_BUILD_SERVER=OFF \
            ${EXTRA_CMAKE}

      - name: Build
        run: cmake --build build --config Release -j $(nproc)

      - name: Package whisper-cli and whisper-bench (Ubuntu)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        run: |
          mkdir -p dist
          cp build/bin/whisper-cli build/bin/whisper-bench dist/
          pushd dist
          zip -9 "whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}.zip" whisper-cli whisper-bench
          popd

      - name: Upload whisper-cli package
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: whisper-cli-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}
          path: dist/whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}.zip

      - name: Cleanup workspace
        if: always()
        run: |
          rm -rf build dist
          sudo rm -rf /var/cache/apt/archives || true

  ubuntu-build-cuda-x64:
    needs: determine-tag
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || github.event.inputs.run_type == 'full-ci' || github.event.inputs.run_type == 'release-only' }}
    name: Ubuntu x64 (CUDA)
    runs-on: ubuntu-22.04
    env:
      ARCH: x64
      DEB_ARCH: amd64
      TRIPLET: x86_64-linux-gnu
      COMPILER_PACKAGES: ""
      BLAS_PACKAGE: ""
      PACKAGE_SUFFIX: "-cuda"
      EXTRA_CMAKE: "-DWHISPER_SDL2=ON -DGGML_CUDA=ON -DGGML_VULKAN=OFF"
      CUDA_VERSION: "12.4"

    steps:
      - name: Clone
        uses: actions/checkout@v4

      - name: Cache CUDA Toolkit
        id: cache-cuda
        uses: actions/cache@v4
        with:
          path: /usr/local/cuda-${{ env.CUDA_VERSION }}
          key: ${{ runner.os }}-cuda-${{ env.CUDA_VERSION }}

      - name: Check CUDA cache status
        run: |
          if [ "${{ steps.cache-cuda.outputs.cache-hit }}" == "true" ]; then
            echo "CUDA cache hit - using cached installation"
            echo "Installation time saved: ~5-10 minutes"
          else
            echo "CUDA cache miss - will install and cache for future runs"
            echo "This will take approximately 5-10 minutes"
          fi

      - name: Install CUDA Toolkit
        if: steps.cache-cuda.outputs.cache-hit != 'true'
        run: |
          # Install CUDA repository
          wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2204/x86_64/cuda-keyring_1.0-1_all.deb
          sudo dpkg -i cuda-keyring_1.0-1_all.deb
          sudo apt-get update
          
          # Install minimal CUDA toolkit to minimize disk usage
          # Using cuda-minimal-build metapackage which includes only build essentials
          sudo apt-get install -y cuda-minimal-build-12-4 cuda-libraries-dev-12-4

      - name: Set CUDA environment variables
        run: |
          echo "CUDA_PATH=/usr/local/cuda-${{ env.CUDA_VERSION }}" >> $GITHUB_ENV
          echo "/usr/local/cuda-${{ env.CUDA_VERSION }}/bin" >> $GITHUB_PATH
          echo "LD_LIBRARY_PATH=/usr/local/cuda-${{ env.CUDA_VERSION }}/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}" >> $GITHUB_ENV

      - name: Install dependencies
        run: |
          sudo dpkg --add-architecture ${DEB_ARCH}
          sudo apt-get update
          EXTRA_PACKAGES=""
          if [[ -n "${BLAS_PACKAGE}" ]]; then
            EXTRA_PACKAGES="${BLAS_PACKAGE}:${DEB_ARCH}"
          fi
          sudo apt-get install -y build-essential cmake ninja-build pkg-config \
            ${COMPILER_PACKAGES} \
            libsdl2-dev:${DEB_ARCH} \
            $EXTRA_PACKAGES
          sudo apt-get clean
          sudo rm -rf /var/lib/apt/lists/*

      - name: Configure
        run: |
          git config --global --add safe.directory /workspace
          export PKG_CONFIG_LIBDIR="/usr/lib/${TRIPLET}/pkgconfig:/usr/share/pkgconfig"
          cmake -S . -B build -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DGGML_VULKAN=OFF \
            -DBUILD_SHARED_LIBS=OFF \
            -DGGML_STATIC=ON \
            -DWHISPER_BUILD_EXAMPLES=ON \
            -DWHISPER_BUILD_TESTS=OFF \
            -DWHISPER_BUILD_SERVER=OFF \
            ${EXTRA_CMAKE}

      - name: Build
        run: cmake --build build --config Release -j $(nproc)

      - name: Package whisper-cli and whisper-bench (Ubuntu)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        run: |
          mkdir -p dist
          cp build/bin/whisper-cli build/bin/whisper-bench dist/
          pushd dist
          zip -9 "whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}.zip" whisper-cli whisper-bench
          popd

      - name: Upload whisper-cli package
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: whisper-cli-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}
          path: dist/whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}.zip

      - name: Cleanup workspace
        if: always()
        run: |
          rm -rf build dist
          sudo rm -rf /var/cache/apt/archives || true

  ubuntu-build-oneapi-x64:
    needs: determine-tag
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || github.event.inputs.run_type == 'full-ci' || github.event.inputs.run_type == 'release-only' }}
    name: Ubuntu x64 (IntelGPU)
    runs-on: ubuntu-22.04
    env:
      ARCH: x64
      DEB_ARCH: amd64
      TRIPLET: x86_64-linux-gnu
      PACKAGE_SUFFIX: "-oneapi"
      ONEAPI_VERSION: "2024.1"
      ONEAPI_INSTALL_PATH: /opt/intel/oneapi

    steps:
      - name: Clone
        uses: actions/checkout@v4

      - name: Cache Intel oneAPI
        id: cache-oneapi
        uses: actions/cache@v4
        with:
          path: ${{ env.ONEAPI_INSTALL_PATH }}
          key: ${{ runner.os }}-oneapi-${{ env.ONEAPI_VERSION }}

      - name: Check oneAPI cache status
        run: |
          if [ "${{ steps.cache-oneapi.outputs.cache-hit }}" == "true" ]; then
            echo "oneAPI cache hit - using cached installation"
            echo "Installation time saved: ~20 minutes"
          else
            echo "oneAPI cache miss - will install and cache for future runs"
            echo "This will take approximately 15-20 minutes"
          fi

      - name: Install Intel oneAPI Base Toolkit
        if: steps.cache-oneapi.outputs.cache-hit != 'true'
        run: |
          echo "Installing Intel oneAPI Base Toolkit..."
          echo "Note: This installation will be cached for subsequent workflow runs."
          
          # Add Intel repository
          wget -O- https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB | gpg --dearmor | sudo tee /usr/share/keyrings/oneapi-archive-keyring.gpg > /dev/null
          echo "deb [signed-by=/usr/share/keyrings/oneapi-archive-keyring.gpg] https://apt.repos.intel.com/oneapi all main" | sudo tee /etc/apt/sources.list.d/oneAPI.list
          
          # Install oneAPI Base Toolkit
          sudo apt-get update
          sudo apt-get install -y intel-oneapi-compiler-dpcpp-cpp intel-oneapi-mkl-devel
          
          echo "Installation completed successfully"

      - name: Set oneAPI environment variables and verify installation
        run: |
          if [ ! -d "${{ env.ONEAPI_INSTALL_PATH }}" ]; then
            echo "✗ Error: oneAPI installation directory not found at: ${{ env.ONEAPI_INSTALL_PATH }}"
            exit 1
          fi
          
          if [ ! -f "${{ env.ONEAPI_INSTALL_PATH }}/setvars.sh" ]; then
            echo "✗ Error: setvars.sh not found - oneAPI installation may be incomplete"
            exit 1
          fi
          
          echo "✓ oneAPI installation verified at: ${{ env.ONEAPI_INSTALL_PATH }}"
          echo "✓ Essential components found (setvars.sh)"
          
          # Source oneAPI environment
          source ${{ env.ONEAPI_INSTALL_PATH }}/setvars.sh
          
          # Verify compiler is available
          which icpx || (echo "✗ Error: icpx compiler not found" && exit 1)
          echo "✓ icpx compiler found"

      - name: Install dependencies
        run: |
          sudo dpkg --add-architecture ${DEB_ARCH}
          sudo apt-get update
          sudo apt-get install -y build-essential cmake ninja-build pkg-config \
            libsdl2-dev:${DEB_ARCH}

      - name: Configure (Intel GPU)
        run: |
          source ${{ env.ONEAPI_INSTALL_PATH }}/setvars.sh
          cmake -S . -B build -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_C_COMPILER=icx \
            -DCMAKE_CXX_COMPILER=icpx \
            -DBUILD_SHARED_LIBS=OFF \
            -DGGML_STATIC=ON \
            -DGGML_SYCL=ON \
            -DGGML_SYCL_F16=ON \
            -DWHISPER_SYCL=ON \
            -DWHISPER_SYCL_F16=ON \
            -DWHISPER_SDL2=OFF \
            -DWHISPER_BUILD_TESTS=OFF \
            -DWHISPER_BUILD_EXAMPLES=ON \
            -DWHISPER_BUILD_SERVER=OFF

      - name: Build (Intel GPU)
        run: |
          source ${{ env.ONEAPI_INSTALL_PATH }}/setvars.sh
          cmake --build build --config Release -j $(nproc)

      - name: Package whisper-cli and whisper-bench (Ubuntu)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        run: |
          mkdir -p dist
          cp build/bin/whisper-cli build/bin/whisper-bench dist/
          
          # Copy Intel oneAPI runtime libraries required for execution
          # These libraries are needed to run SYCL-compiled binaries
          source ${{ env.ONEAPI_INSTALL_PATH }}/setvars.sh
          cp ${{ env.ONEAPI_INSTALL_PATH }}/compiler/latest/lib/libsycl.so* dist/ 2>/dev/null || echo "Warning: libsycl.so not found"
          cp ${{ env.ONEAPI_INSTALL_PATH }}/compiler/latest/lib/libpi_*.so dist/ 2>/dev/null || echo "Warning: pi libraries not found"
          cp ${{ env.ONEAPI_INSTALL_PATH }}/compiler/latest/lib/libOpenCL.so* dist/ 2>/dev/null || true
          cp ${{ env.ONEAPI_INSTALL_PATH }}/compiler/latest/lib/libsvml.so* dist/ 2>/dev/null || true
          cp ${{ env.ONEAPI_INSTALL_PATH }}/compiler/latest/lib/libirng.so* dist/ 2>/dev/null || true
          cp ${{ env.ONEAPI_INSTALL_PATH }}/compiler/latest/lib/libimf.so* dist/ 2>/dev/null || true
          cp ${{ env.ONEAPI_INSTALL_PATH }}/compiler/latest/lib/libintlc.so* dist/ 2>/dev/null || true
          
          pushd dist
          zip -9 "whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}.zip" whisper-cli whisper-bench *.so*
          popd

      - name: Upload whisper-cli package
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: whisper-cli-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}
          path: dist/whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-ubuntu-${{ env.ARCH }}${{ env.PACKAGE_SUFFIX }}.zip


  macos-build:
    needs: determine-tag
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || github.event.inputs.run_type == 'full-ci' || github.event.inputs.run_type == 'release-only' }}
    name: macOS ${{ matrix.name }}
    runs-on: macos-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: Metal + CoreML
            coreml: ON
            suffix: coreml
          - name: Metal only
            coreml: OFF
            suffix: metal

    steps:
      - name: Clone
        uses: actions/checkout@v4

      - name: Dependencies
        run: |
          brew update
          cmake --version
          brew install sdl2

      - name: Build
        run: |
          sysctl -a
          git config --global --add safe.directory /workspace
          cmake -B build -G Xcode \
            -DGGML_METAL_USE_BF16=ON \
            -DGGML_METAL_EMBED_LIBRARY=ON \
            -DGGML_COREML=${{ matrix.coreml }} \
            -DBUILD_SHARED_LIBS=OFF \
            -DGGML_STATIC=ON \
            -DWHISPER_BUILD_EXAMPLES=ON \
            -DWHISPER_BUILD_TESTS=OFF \
            -DWHISPER_BUILD_SERVER=OFF \
            -DCMAKE_OSX_ARCHITECTURES="arm64;x86_64"
          cmake --build build --config Release -j $(sysctl -n hw.logicalcpu)

      - name: Package whisper-cli and whisper-bench
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        run: |
          mkdir -p dist
          cp build/bin/Release/whisper-cli build/bin/Release/whisper-bench dist/
          pushd dist
          zip -9 "whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-macos-universal-${{ matrix.suffix }}.zip" whisper-cli whisper-bench
          popd

      - name: Upload whisper-cli package
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: whisper-cli-macos-${{ matrix.suffix }}
          path: dist/whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-macos-universal-${{ matrix.suffix }}.zip



  windows-build-vulkan-msvc:
    needs: determine-tag
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || github.event.inputs.run_type == 'full-ci' || github.event.inputs.run_type == 'release-only' }}
    name: Windows x64 (Vulkan)
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64

    runs-on: windows-latest
    
    env:
      VULKAN_SDK_VERSION: "1.4.328.1"

    steps:
      - name: Clone
        uses: actions/checkout@v4

      - name: Install Ninja
        run: choco install ninja -y

      - name: Cache Vulkan SDK
        id: cache-vulkan
        uses: actions/cache@v4
        with:
          path: C:\VulkanSDK
          key: ${{ runner.os }}-vulkan-msvc-${{ env.VULKAN_SDK_VERSION }}

      - name: Install Vulkan SDK
        if: steps.cache-vulkan.outputs.cache-hit != 'true'
        shell: powershell
        run: |
          $ErrorActionPreference = 'Stop'
          Write-Host "Vulkan SDK cache miss - installing"
          Write-Host "Installing Vulkan SDK via winget"

          $installArgs = @(
            'install',
            '--id', 'KhronosGroup.VulkanSDK',
            '--accept-package-agreements',
            '--accept-source-agreements',
            '--silent',
            '--source', 'winget'
          )

          winget @installArgs

          if ($LASTEXITCODE -ne 0) {
            Write-Error "winget failed to install Vulkan SDK (exit $LASTEXITCODE)"
            exit $LASTEXITCODE
          }

      - name: Locate Vulkan SDK
        shell: powershell
        run: |
          $searchRoots = @(
            "C:\\VulkanSDK",
            "$Env:ProgramFiles\\VulkanSDK",
            "$Env:ProgramFiles(x86)\\VulkanSDK"
          )

          $sdkRoot = $null
          foreach ($root in $searchRoots) {
            if (-not (Test-Path $root)) {
              continue
            }

            $candidate = Get-ChildItem $root -Directory | Sort-Object Name -Descending | Select-Object -First 1
            if ($candidate) {
              $sdkRoot = $candidate.FullName
              break
            }
          }

          if (-not $sdkRoot) {
            Write-Error "Vulkan SDK not found"
            exit 1
          }
          
          $cacheHit = '${{ steps.cache-vulkan.outputs.cache-hit }}'
          if ($cacheHit -eq 'true') {
            Write-Host "Vulkan SDK cache hit - using cached installation at: $sdkRoot"
          } else {
            Write-Host "Vulkan SDK installed at: $sdkRoot"
          }

          "VULKAN_SDK=$sdkRoot" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append

      - name: Configure (Vulkan MSVC)
        shell: cmd
        run: |
          for /f "usebackq tokens=*" %%i in (`"%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe" -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath`) do set VS_PATH=%%i
          if not defined VS_PATH exit /b 1
          call "%VS_PATH%\Common7\Tools\VsDevCmd.bat" -host_arch=x64 -arch=x64
          if not defined VULKAN_SDK exit /b 1
          set "PATH=%VULKAN_SDK%\Bin;%PATH%"
          cmake -S . -B build -G "Ninja" ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DBUILD_SHARED_LIBS=OFF ^
            -DGGML_STATIC=ON ^
            -DGGML_VULKAN=ON ^
            -DWHISPER_SDL2=OFF ^
            -DWHISPER_BUILD_TESTS=OFF ^
            -DWHISPER_BUILD_EXAMPLES=ON ^
            -DWHISPER_BUILD_SERVER=OFF

      - name: Build (Vulkan MSVC)
        shell: cmd
        run: |
          for /f "usebackq tokens=*" %%i in (`"%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe" -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath`) do set VS_PATH=%%i
          if not defined VS_PATH exit /b 1
          call "%VS_PATH%\Common7\Tools\VsDevCmd.bat" -host_arch=x64 -arch=x64
          if not defined VULKAN_SDK exit /b 1
          set "PATH=%VULKAN_SDK%\Bin;%PATH%"
          cmake --build build --config Release -- -v

      - name: Package whisper-cli and whisper-bench (Windows ${{ matrix.arch }} Vulkan MSVC)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        shell: powershell
        run: |
          # Create dist directory
          New-Item -ItemType Directory -Force -Path dist | Out-Null
          
          # Copy executables
          Copy-Item build\bin\whisper-cli.exe dist\
          Copy-Item build\bin\whisper-bench.exe dist\
          
          # Copy any build DLLs if they exist
          if (Test-Path "build\bin\*.dll") {
            Copy-Item build\bin\*.dll dist\
          }
          
          # Create zip package
          Push-Location dist
          $filesToZip = @(Get-ChildItem -Path "*.exe" -Name)
          if (Test-Path "*.dll") {
            $filesToZip += @(Get-ChildItem -Path "*.dll" -Name)
          }
          tar.exe -a -c -f ..\whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-vulkan-msvc.zip $filesToZip
          Pop-Location
          Move-Item whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-vulkan-msvc.zip dist\

      - name: Upload whisper-cli package (Windows ${{ matrix.arch }} Vulkan MSVC)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: whisper-cli-windows-${{ matrix.arch }}-vulkan-msvc
          path: dist/whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-vulkan-msvc.zip

  windows-build-intelgpu:
    needs: determine-tag
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || github.event.inputs.run_type == 'full-ci' || github.event.inputs.run_type == 'release-only' }}
    name: Windows x64 (IntelGPU)
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64

    runs-on: windows-latest
    
    env:
      # Standard Intel oneAPI installation directory on Windows (oneAPI 2024.x)
      # Update this path if Intel changes their default installation location
      ONEAPI_INSTALL_PATH: C:\Program Files (x86)\Intel\oneAPI
      # oneAPI version for cache key - update when upgrading oneAPI
      ONEAPI_VERSION: "2024.1"

    steps:
      - name: Clone
        uses: actions/checkout@v4

      - name: Install Ninja
        run: choco install ninja -y

      - name: Cache Intel oneAPI
        id: cache-oneapi
        uses: actions/cache@v4
        with:
          path: ${{ env.ONEAPI_INSTALL_PATH }}
          # Cache key includes oneAPI version only - cache is shared across branches
          key: ${{ runner.os }}-oneapi-${{ env.ONEAPI_VERSION }}

      - name: Check oneAPI cache status
        shell: powershell
        run: |
          $cacheHit = '${{ steps.cache-oneapi.outputs.cache-hit }}'
          if ($cacheHit -eq 'true') {
            Write-Host "oneAPI cache hit - using cached installation"
            Write-Host "Installation time saved: ~20 minutes"
          } else {
            Write-Host "oneAPI cache miss - will install and cache for future runs"
            Write-Host "This will take approximately 15-20 minutes"
          }

      - name: Install Intel oneAPI Base Toolkit
        if: steps.cache-oneapi.outputs.cache-hit != 'true'
        shell: powershell
        run: |
          Write-Host "Installing Intel oneAPI Base Toolkit..."
          Write-Host "Note: This installation will be cached for subsequent workflow runs."
          
          # Install via winget - most reliable method
          # The installation is cached, so this only runs once
          winget install `
            --id Intel.oneAPI.BaseToolkit `
            --accept-package-agreements `
            --accept-source-agreements `
            --silent `
            --log "$env:TEMP\oneapi_install.log"
          
          if ($LASTEXITCODE -ne 0) {
            Write-Host "✗ Error: Installation failed with exit code $LASTEXITCODE"
            Write-Host "Check log at: $env:TEMP\oneapi_install.log"
            Write-Host ""
            Write-Host "Installation failed and cannot continue."
            exit 1
          } else {
            Write-Host "Installation completed successfully"
          }

      - name: Set oneAPI environment variables and verify installation
        shell: powershell
        run: |
          echo "ONEAPI_ROOT=$env:ONEAPI_INSTALL_PATH" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append
          
          # Verify essential components are present
          $setvarsPath = Join-Path $env:ONEAPI_INSTALL_PATH "setvars.bat"
          $compilerPath = Join-Path $env:ONEAPI_INSTALL_PATH "compiler"
          
          $installValid = $true
          
          if (-not (Test-Path $env:ONEAPI_INSTALL_PATH)) {
            Write-Host "✗ Error: oneAPI installation directory not found at: $env:ONEAPI_INSTALL_PATH"
            $installValid = $false
          } elseif (-not (Test-Path $setvarsPath)) {
            Write-Host "✗ Error: setvars.bat not found - oneAPI installation may be incomplete"
            $installValid = $false
          } elseif (-not (Test-Path $compilerPath)) {
            Write-Host "✗ Error: Compiler directory not found - oneAPI installation may be incomplete"
            $installValid = $false
          } else {
            Write-Host "✓ oneAPI installation verified at: $env:ONEAPI_INSTALL_PATH"
            Write-Host "✓ Essential components found (setvars.bat, compiler)"
          }
          
          if (-not $installValid) {
            Write-Host ""
            Write-Host "Installation validation failed. The build will likely fail."
            Write-Host "This can happen if:"
            Write-Host "  1. Installation was interrupted or incomplete"
            Write-Host "  2. Cache was corrupted"
            Write-Host "  3. Disk space ran out during installation"
            Write-Host ""
            Write-Host "To fix: Manually invalidate the cache and re-run the workflow"
            exit 1
          }

      - name: Configure (Intel GPU)
        shell: cmd
        run: |
          call "%ONEAPI_ROOT%\setvars.bat"
          cmake -S . -B build -G Ninja ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DCMAKE_C_COMPILER=icx ^
            -DCMAKE_CXX_COMPILER=icx ^
            -DBUILD_SHARED_LIBS=OFF ^
            -DGGML_STATIC=ON ^
            -DGGML_SYCL=ON ^
            -DGGML_SYCL_F16=ON ^
            -DWHISPER_SYCL=ON ^
            -DWHISPER_SYCL_F16=ON ^
            -DWHISPER_SDL2=OFF ^
            -DWHISPER_BUILD_TESTS=OFF ^
            -DWHISPER_BUILD_EXAMPLES=ON ^
            -DWHISPER_BUILD_SERVER=OFF

      - name: Build (Intel GPU)
        shell: cmd
        run: |
          call "%ONEAPI_ROOT%\setvars.bat"
          cmake --build build --config Release -- -v

      - name: Package whisper-cli and whisper-bench (Windows ${{ matrix.arch }} IntelGPU)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        shell: powershell
        run: |
          # Create dist directory
          New-Item -ItemType Directory -Force -Path dist | Out-Null
          
          # Copy executables and build DLLs
          Copy-Item build\bin\whisper-cli.exe dist\
          Copy-Item build\bin\whisper-bench.exe dist\
          if (Test-Path "build\bin\*.dll") {
            Copy-Item build\bin\*.dll dist\
          }
          
          # Copy Intel oneAPI runtime DLLs required for execution
          # Core compiler runtime DLLs
          $coreDlls = @(
            'svml_dispmd.dll',
            'libmmd.dll',
            'libiomp5md.dll'
          )
          
          # SYCL runtime DLLs (try multiple versions for compatibility)
          $syclDlls = @(
            'sycl.dll',
            'sycl7.dll',
            'sycl8.dll'
          )
          
          # oneDNN DLLs
          $dnnlDlls = @(
            'dnnl.dll',
            'dnnld.dll'
          )
          
          # MKL SYCL DLLs (essential for SYCL math operations)
          $mklSyclDlls = @(
            'mkl_sycl_blas.5.dll',
            'mkl_sycl_lapack.5.dll',
            'mkl_sycl_vm.5.dll',
            'mkl_core.2.dll',
            'mkl_intel_thread.2.dll',
            'mkl_tbb_thread.2.dll'
          )
          
          # Combine all DLL lists
          $dllsToCopy = $coreDlls + $syclDlls + $dnnlDlls + $mklSyclDlls
          
          # Search multiple locations for DLLs
          $dllLocations = @(
            "$env:ONEAPI_ROOT\compiler\latest\bin",
            "$env:ONEAPI_ROOT\compiler\latest\windows\bin",
            "$env:ONEAPI_ROOT\dnnl\latest\bin",
            "$env:ONEAPI_ROOT\mkl\latest\bin",
            "$env:ONEAPI_ROOT\mkl\latest\redist\intel64",
            "$env:ONEAPI_ROOT\tbb\latest\redist\intel64\vc_mt"
          )
          
          foreach ($dll in $dllsToCopy) {
            $found = $false
            foreach ($location in $dllLocations) {
              if (Test-Path $location) {
                $sourcePath = Join-Path $location $dll
                if (Test-Path $sourcePath) {
                  Copy-Item $sourcePath dist\
                  Write-Host "Copied $dll from $location"
                  $found = $true
                  break
                }
              }
            }
            if (-not $found) {
              Write-Host "Warning: $dll not found in any location"
            }
          }
          
          # Copy PI (Plugin Interface) DLLs - these may be in bin or bin\plugins
          $piLocations = @(
            "$env:ONEAPI_ROOT\compiler\latest\bin",
            "$env:ONEAPI_ROOT\compiler\latest\bin\plugins",
            "$env:ONEAPI_ROOT\compiler\latest\windows\bin",
            "$env:ONEAPI_ROOT\compiler\latest\windows\bin\plugins"
          )
          
          $piDlls = @('pi_level_zero.dll', 'pi_opencl.dll', 'pi_cuda.dll', 'pi_hip.dll')
          $piCopied = 0
          
          foreach ($location in $piLocations) {
            if (Test-Path $location) {
              foreach ($piDll in $piDlls) {
                $piPath = Join-Path $location $piDll
                $destPath = Join-Path "dist" $piDll
                if ((Test-Path $piPath) -and -not (Test-Path $destPath)) {
                  Copy-Item $piPath dist\
                  Write-Host "Copied $piDll from $location"
                  $piCopied++
                }
              }
            }
          }
          
          if ($piCopied -eq 0) {
            Write-Host "Warning: No PI plugin DLLs found"
          } else {
            Write-Host "Copied $piCopied PI plugin DLLs"
          }
          
          # Create zip package
          Push-Location dist
          $filesToZip = @(Get-ChildItem -Path "*.exe" -Name)
          if (Test-Path "*.dll") {
            $filesToZip += @(Get-ChildItem -Path "*.dll" -Name)
          }
          tar.exe -a -c -f ..\whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-intelgpu.zip $filesToZip
          Pop-Location
          Move-Item whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-intelgpu.zip dist\

      - name: Upload whisper-cli package (Windows ${{ matrix.arch }} IntelGPU)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: whisper-cli-windows-${{ matrix.arch }}-intelgpu
          path: dist/whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-intelgpu.zip

  windows-build-cuda:
    needs: determine-tag
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' || github.event.inputs.run_type == 'full-ci' || github.event.inputs.run_type == 'release-only' }}
    name: Windows x64 (CUDA)
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64

    runs-on: windows-latest
    
    env:
      # CUDA Toolkit installation directory on Windows
      CUDA_PATH: C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.4
      # CUDA version for cache key - update when upgrading CUDA
      CUDA_VERSION: "12.4.1"

    steps:
      - name: Clone
        uses: actions/checkout@v4

      - name: Install Ninja
        run: choco install ninja -y

      - name: Cache CUDA Toolkit
        id: cache-cuda
        uses: actions/cache@v4
        with:
          path: C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA
          # Cache key includes CUDA version only - cache is shared across branches
          key: ${{ runner.os }}-cuda-${{ env.CUDA_VERSION }}

      - name: Check CUDA cache status
        shell: powershell
        run: |
          $cacheHit = '${{ steps.cache-cuda.outputs.cache-hit }}'
          if ($cacheHit -eq 'true') {
            Write-Host "CUDA cache hit - using cached installation"
            Write-Host "Installation time saved: ~10 minutes"
          } else {
            Write-Host "CUDA cache miss - will install and cache for future runs"
            Write-Host "This will take approximately 10 minutes"
          }

      - name: Install CUDA Toolkit
        if: steps.cache-cuda.outputs.cache-hit != 'true'
        shell: powershell
        run: |
          Write-Host "Installing NVIDIA CUDA Toolkit..."
          Write-Host "Note: This installation will be cached for subsequent workflow runs."
          
          # Install CUDA Toolkit via Chocolatey (better CUDA support than winget)
          # Note: Chocolatey cuda package doesn't support patch versions (e.g., 12.4.1)
          # Install latest CUDA 12.x available
          choco install cuda -y --no-progress
          
          if ($LASTEXITCODE -ne 0) {
            Write-Host "Error: Installation failed with exit code $LASTEXITCODE"
            Write-Host ""
            Write-Host "Installation failed and cannot continue."
            exit 1
          } else {
            Write-Host "Installation completed successfully"
          }

      - name: Set CUDA environment variables and verify installation
        shell: powershell
        run: |
          # Detect actual CUDA installation path
          # Chocolatey installs latest version which may differ from our env var
          $cudaBasePath = "C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA"
          
          if (Test-Path $cudaBasePath) {
            # Find the installed CUDA version directory
            $installedVersions = Get-ChildItem -Path $cudaBasePath -Directory | Where-Object { $_.Name -match '^v\d+\.\d+$' } | Sort-Object Name -Descending
            
            if ($installedVersions.Count -gt 0) {
              $actualCudaPath = $installedVersions[0].FullName
              Write-Host "Detected CUDA installation at: $actualCudaPath"
              
              # Set CUDA environment variables with actual path
              echo "CUDA_PATH=$actualCudaPath" | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append
              
              # Add CUDA to PATH
              $cudaBinPath = Join-Path $actualCudaPath "bin"
              echo "$cudaBinPath" | Out-File -FilePath $Env:GITHUB_PATH -Encoding utf8 -Append
              
              # Verify essential components are present
              $nvccPath = Join-Path $actualCudaPath "bin\nvcc.exe"
              $includeDir = Join-Path $actualCudaPath "include"
              $libDir = Join-Path $actualCudaPath "lib\x64"
              
              $installValid = $true
              
              if (-not (Test-Path $nvccPath)) {
                Write-Host "Error: nvcc.exe not found - CUDA installation may be incomplete"
                $installValid = $false
              } elseif (-not (Test-Path $includeDir)) {
                Write-Host "Error: Include directory not found - CUDA installation may be incomplete"
                $installValid = $false
              } elseif (-not (Test-Path $libDir)) {
                Write-Host "Error: Library directory not found - CUDA installation may be incomplete"
                $installValid = $false
              } else {
                Write-Host "CUDA Toolkit verified at: $actualCudaPath"
                Write-Host "Essential components found (nvcc.exe, include, lib)"
              }
              
              if (-not $installValid) {
                Write-Host ""
                Write-Host "Installation validation failed. The build will likely fail."
                exit 1
              }
            } else {
              Write-Host "Error: No CUDA version directories found in $cudaBasePath"
              exit 1
            }
          } else {
            Write-Host "Error: CUDA base directory not found at $cudaBasePath"
            exit 1
          }

      - name: Configure (CUDA)
        shell: cmd
        run: |
          for /f "usebackq tokens=*" %%i in (`"%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe" -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath`) do set VS_PATH=%%i
          if not defined VS_PATH exit /b 1
          call "%VS_PATH%\Common7\Tools\VsDevCmd.bat" -host_arch=x64 -arch=x64
          cmake -S . -B build -G Ninja ^
            -DCMAKE_BUILD_TYPE=Release ^
            -DBUILD_SHARED_LIBS=OFF ^
            -DGGML_STATIC=ON ^
            -DGGML_CUDA=ON ^
            -DWHISPER_SDL2=OFF ^
            -DWHISPER_BUILD_TESTS=OFF ^
            -DWHISPER_BUILD_EXAMPLES=ON ^
            -DWHISPER_BUILD_SERVER=OFF

      - name: Build (CUDA)
        shell: cmd
        run: |
          for /f "usebackq tokens=*" %%i in (`"%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe" -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath`) do set VS_PATH=%%i
          if not defined VS_PATH exit /b 1
          call "%VS_PATH%\Common7\Tools\VsDevCmd.bat" -host_arch=x64 -arch=x64
          cmake --build build --config Release -- -v

      - name: Package whisper-cli and whisper-bench (Windows ${{ matrix.arch }} CUDA)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        shell: powershell
        run: |
          # Create dist directory
          New-Item -ItemType Directory -Force -Path dist | Out-Null
          
          # Copy executables
          Copy-Item build\bin\whisper-cli.exe dist\
          Copy-Item build\bin\whisper-bench.exe dist\
          
          # Copy any build DLLs if they exist
          if (Test-Path "build\bin\*.dll") {
            Copy-Item build\bin\*.dll dist\
          }
          
          # Copy CUDA DLLs from CUDA_PATH\bin
          # Only copy essential runtime DLLs to minimize package size
          if ($env:CUDA_PATH -and (Test-Path "$env:CUDA_PATH\bin")) {
            Write-Host "Copying essential CUDA runtime DLLs from: $env:CUDA_PATH\bin"
            $cudaDllPatterns = @('cudart*.dll', 'cublas*.dll', 'cublasLt*.dll', 'curand*.dll', 'cusparse*.dll', 'cusolver*.dll', 'cufft*.dll', 'nvrtc*.dll')
            $copiedCount = 0
            foreach ($pattern in $cudaDllPatterns) {
              Get-ChildItem "$env:CUDA_PATH\bin\$pattern" -ErrorAction SilentlyContinue | ForEach-Object {
                Copy-Item $_.FullName dist\
                Write-Host "Copied $($_.Name)"
                $copiedCount++
              }
            }
            if ($copiedCount -eq 0) {
              Write-Host "Warning: No CUDA DLLs found matching patterns"
            } else {
              Write-Host "Copied $copiedCount CUDA DLLs"
            }
          } else {
            Write-Host "Warning: CUDA_PATH not set or bin directory not found"
          }
          
          # Create zip package
          Push-Location dist
          $filesToZip = @(Get-ChildItem -Path "*.exe" -Name)
          if (Test-Path "*.dll") {
            $filesToZip += @(Get-ChildItem -Path "*.dll" -Name)
          }
          tar.exe -a -c -f ..\whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-cuda.zip $filesToZip
          Pop-Location
          Move-Item whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-cuda.zip dist\

      - name: Upload whisper-cli package (Windows ${{ matrix.arch }} CUDA)
        if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
        uses: actions/upload-artifact@v4
        with:
          name: whisper-cli-windows-${{ matrix.arch }}-cuda
          path: dist/whisper-cli-${{ needs.determine-tag.outputs.tag_name }}-windows-${{ matrix.arch }}-cuda.zip

  create-release:
    if: ${{ needs.determine-tag.outputs.should_release == 'true' || github.event.inputs.run_type == 'release-only' }}
    needs: [determine-tag, ubuntu-build-vulkan-x64, ubuntu-build-cuda-x64, ubuntu-build-oneapi-x64, macos-build, windows-build-intelgpu, windows-build-vulkan-msvc, windows-build-cuda]
    runs-on: ubuntu-latest

    steps:
      - name: Download whisper-cli packages
        uses: actions/download-artifact@v4
        with:
          pattern: whisper-cli-*
          path: release
          merge-multiple: true

      # Full packages are available as workflow artifacts but excluded from releases to reduce size
      # Uncomment below to include full packages (with all examples) in releases
      # - name: Download full packages
      #   uses: actions/download-artifact@v4
      #   with:
      #     pattern: whisper.cpp-full-*
      #     path: release
      #     merge-multiple: true

      - name: Create GitHub release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.determine-tag.outputs.tag_name }}
          files: |
            release/*
          generate_release_notes: true
          prerelease: ${{ github.ref_type != 'tag' }}
